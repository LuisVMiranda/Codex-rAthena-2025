From f2160635bece70d8551c6c464b0845c18d4ba31d Mon Sep 17 00:00:00 2001
From: raffles <53240858+holic-cat@users.noreply.github.com>
Date: Sun, 4 Aug 2024 23:35:37 +0800
Subject: [PATCH] Sonic Blow Diff

---
 db/skill_animation.txt |   7 +++
 src/map/clif.cpp       |  67 +++++++++++++++++++-
 src/map/clif.hpp       |   3 +-
 src/map/pc.cpp         |   4 ++
 src/map/pc.hpp         |   5 ++
 src/map/skill.cpp      | 138 ++++++++++++++++++++++++++++++++++++++++-
 src/map/skill.hpp      |  24 +++++++
 7 files changed, 243 insertions(+), 5 deletions(-)
 create mode 100644 db/skill_animation.txt

diff --git a/db/skill_animation.txt b/db/skill_animation.txt
new file mode 100644
index 0000000..da52ba5
--- /dev/null
+++ b/db/skill_animation.txt
@@ -0,0 +1,7 @@
+// Skill Animation
+//
+// Structure of Database:
+// SkillName <Aegis>, Start <Number>, Interval <Number>, Speed <Number>, Count <Number>, Spin <true/false>
+
+AS_SONICBLOW, -1, 180, 180, 8, true
+CG_ARROWVULCAN, -1, 200, 100, 9, false
\ No newline at end of file
diff --git a/src/map/clif.cpp b/src/map/clif.cpp
index 4da184a..86e5534 100644
--- a/src/map/clif.cpp
+++ b/src/map/clif.cpp
@@ -2075,6 +2075,12 @@ void clif_quitsave(int fd,map_session_data *sd) {
 	}
 }
 
+static void clif_changemap_hook(map_session_data& sd)
+{
+	skill_clear_animation(&sd.bl);
+}
+
+
 /// Notifies the client of a position change to coordinates on given map (ZC_NPCACK_MAPMOVE).
 /// 0091 <map name>.16B <x>.W <y>.W
 void clif_changemap( map_session_data& sd, short m, uint16 x, uint16 y ){
@@ -2084,7 +2090,9 @@ void clif_changemap( map_session_data& sd, short m, uint16 x, uint16 y ){
 	mapindex_getmapname_ext(map_mapid2mapname(m), packet.mapName);
 	packet.xPos = x;
 	packet.yPos = y;
-
+	
+	clif_changemap_hook(sd); //Sonic Blow
+	
 	clif_send( &packet, sizeof( packet ), &sd.bl, SELF );
 }
 
@@ -5961,6 +5969,36 @@ void clif_skill_cooldown( map_session_data &sd, uint16 skill_id, t_tick tick ){
 #endif
 }
 
+static int clif_skill_damage_hook(struct block_list* src,struct block_list* dst,t_tick tick,int sdelay,int ddelay,int64 sdamage,int div,uint16 skill_id,uint16 skill_lv,enum e_damage_type type)
+{
+	struct s_animation_data animation = skill_animation_info(skill_id);
+
+	if (animation.skill_id == 0)
+		return 0;
+
+	int start_time = animation.start == -1 ? sdelay : animation.start;
+	int target_id = dst->id;
+	int dir = sdamage != 0 ? unit_getdir(dst) : -1;
+
+	struct s_environment_data *skill_env = nullptr;
+	CREATE(skill_env, struct s_environment_data, 1);
+	skill_env->skill_id = skill_id;
+	skill_env->target_id = target_id;
+	if (animation.spin && dir != -1)
+		dir = skill_calc_dir_counter_clockwise(dir);
+	skill_env->dir = dir;
+
+	if(src->type == BL_PC){
+		BL_CAST(BL_PC,src)->skill_animation.tid = add_timer(tick + start_time + animation.interval, skill_play_animation, src->id, (intptr_t)skill_env);
+		BL_CAST(BL_PC,src)->skill_animation.step = 1;
+	}else
+		add_timer(tick + start_time + animation.interval, skill_play_animation, src->id, (intptr_t)skill_env);
+
+	aFree(skill_env);
+	return 0;
+}
+
+
 /// Skill attack effect and damage.
 /// 0114 <skill id>.W <src id>.L <dst id>.L <tick>.L <src delay>.L <dst delay>.L <damage>.W <level>.W <div>.W <type>.B (ZC_NOTIFY_SKILL)
 /// 01de <skill id>.W <src id>.L <dst id>.L <tick>.L <src delay>.L <dst delay>.L <damage>.L <level>.W <div>.W <type>.B (ZC_NOTIFY_SKILL2)
@@ -6051,7 +6089,7 @@ int clif_skill_damage(struct block_list *src,struct block_list *dst,t_tick tick,
 		clif_send(buf,packet_len(0x1de),src,SELF);
 	}
 #endif
-
+	clif_skill_damage_hook(src,dst,tick,sdelay,ddelay,sdamage,div,skill_id,skill_lv,type);
 	//Because the damage delay must be synced with the client, here is where the can-walk tick must be updated. [Skotlex]
 	return clif_calc_walkdelay(dst,ddelay,type,damage,div);
 }
@@ -25140,6 +25178,31 @@ void clif_specialpopup(map_session_data& sd, int32 id ){
 	clif_send( &p, sizeof( p ), &sd.bl, SELF);
 #endif
 }
+void clif_send_animation_motion(struct block_list* bl, int target_id, int motion_speed) {
+    // Add logging for debugging
+    printf("Sending animation motion: bl_id=%d, target_id=%d, motion_speed=%d\n", bl->id, target_id, motion_speed);
+
+    unsigned char buf[32];
+    nullpo_retv(bl);
+    WBUFW(buf, 0) = 0x8a;
+    WBUFL(buf, 2) = bl->id;
+    WBUFL(buf, 14) = motion_speed;
+    WBUFB(buf, 26) = 10;
+    clif_send(buf, packet_len(0x8a), bl, AREA);
+}
+
+void clif_send_animation_dir(struct block_list* src, int target_id, int dir) {
+    // Add logging for debugging
+    printf("Sending animation direction: src_id=%d, target_id=%d, dir=%d\n", src->id, target_id, dir);
+
+    unsigned char buf[64];
+    WBUFW(buf, 0) = 0x9c;
+    WBUFL(buf, 2) = target_id;
+    WBUFW(buf, 6) = 0;
+    WBUFB(buf, 8) = dir;
+    clif_send(buf, packet_len(0x9c), src, AREA);
+}
+
 
 /*==========================================
  * Main client packet processing function
diff --git a/src/map/clif.hpp b/src/map/clif.hpp
index 2b57345..4066337 100644
--- a/src/map/clif.hpp
+++ b/src/map/clif.hpp
@@ -1455,7 +1455,8 @@ void clif_set_npc_window_pos(map_session_data& sd, int x, int y);
 void clif_set_npc_window_pos_percent(map_session_data& sd, int x, int y);
 
 void clif_noask_sub( map_session_data& sd, map_session_data& tsd, int type );
-
 void clif_specialpopup(map_session_data& sd, int32 id);
 
+void clif_send_animation_motion(struct block_list* bl, int target_id, int motion_speed);
+void clif_send_animation_dir(struct block_list* src, int target_id, int dir);
 #endif /* CLIF_HPP */
diff --git a/src/map/pc.cpp b/src/map/pc.cpp
index dfbc927..1ba2fde 100644
--- a/src/map/pc.cpp
+++ b/src/map/pc.cpp
@@ -2065,6 +2065,10 @@ bool pc_authok(map_session_data *sd, uint32 login_id2, time_t expiration_time, i
 	sd->skill_keep_using.level = 0;
 	sd->skill_keep_using.target = 0;
 
+	sd->skill_animation.tid = INVALID_TIMER;
+	sd->skill_animation.step = 0;
+
+
 #ifdef SECURE_NPCTIMEOUT
 	// Initialize to defaults/expected
 	sd->npc_idle_timer = INVALID_TIMER;
diff --git a/src/map/pc.hpp b/src/map/pc.hpp
index 9e75c09..15c4b5d 100644
--- a/src/map/pc.hpp
+++ b/src/map/pc.hpp
@@ -934,6 +934,11 @@ public:
 		int target;
 	} skill_keep_using;
 
+	struct{
+		int tid;
+		int step;
+	} skill
+	
 	struct {
 		std::shared_ptr<s_captcha_data> cd;
 		uint16 upload_size;
diff --git a/src/map/skill.cpp b/src/map/skill.cpp
index 4386258..18d4b48 100644
--- a/src/map/skill.cpp
+++ b/src/map/skill.cpp
@@ -25270,6 +25270,139 @@ static bool skill_parse_row_skilldamage( char* split[], size_t columns, size_t c
 	return true;
 }
 
+int skill_calc_dir_counter_clockwise(int dir)
+{
+	dir += 2;
+	if (dir >= DIR_MAX)
+		dir = dir - DIR_MAX;
+	return dir;
+}
+
+
+static bool skill_parse_skill_animation( char* split[], size_t columns, size_t current ){
+
+	std::string skill_name = split[0];
+	int start = atoi(split[1]);
+	int interval = atoi(split[2]);
+	int speed = atoi(split[3]);
+	int count = atoi(split[4]);
+	std::string spin = split[5];
+
+	util::tolower(spin);
+
+	uint16 skill_id = skill_name2id(skill_name.c_str());
+
+	if(!skill_id){
+		ShowWarning("skill_parse_skill_animation: skill \"%s\" is invalid\n", skill_name.c_str());
+		return false;
+	}
+
+	if(strncmp(spin.c_str(), "true", 4) == 0 || strncmp(spin.c_str(), "false", 5) == 0){
+		ShowWarning("skill_parse_skill_animation: skill \"%s\" , spin setting is in valid\n", skill_name.c_str());
+		return false;
+	}
+
+	bool is_spin = false;
+
+	if(strncmp(spin.c_str(), "true", 4) == 0)
+		is_spin = true;
+
+	struct s_animation_data entry = {};
+	entry.skill_id = skill_id;
+	entry.start = start;
+	entry.interval = interval;
+	entry.motion_speed = speed;
+	entry.motion_count = count;
+	entry.spin = is_spin;
+
+	animation_lists.push_back(entry);
+	return true;
+}
+
+struct s_animation_data skill_animation_info(int skill_id) {
+    for (const auto &it : animation_lists) {
+        if (it.skill_id == skill_id) {
+            return it;
+        }
+    }
+    // Return a default animation structure if none found
+    return {};
+}
+
+// Directions for animation steps; assuming 0 = right, 3 = down, 6 = left, and 9 = up
+int get_direction_for_step(int step) {
+    // Adjust according to your coordinate system
+    switch (step) {
+        case 1: return 0;  // Right
+        case 2: return 3;  // Down
+        case 3: return 6;  // Left
+        case 4: return 9;  // Up
+        case 5: return 12;  // Right
+        case 6: return 3;  // Down
+        case 7: return 6;  // Left
+        case 8: return 9;  // Up
+        default: return 0; // Default direction if step is invalid
+    }
+}
+
+TIMER_FUNC(skill_play_animation) {
+    struct block_list* bl = map_id2bl(id);
+
+    if (bl == NULL || bl->type != BL_PC) {
+        return 0;
+    }
+
+    struct s_environment_data* skill_env = (struct s_environment_data*)data;
+
+    if (skill_env == NULL) {
+        return 0;
+    }
+
+    struct s_animation_data animation = skill_animation_info(skill_env->skill_id);
+
+    if (animation.skill_id == 0) {
+        return 0;
+    }
+
+    map_session_data* sd = BL_CAST(BL_PC, bl);
+
+    if (sd->skill_animation.step < animation.motion_count) {
+        clif_send_animation_motion(bl, skill_env->target_id, animation.motion_speed);
+
+        // Get direction based on current step
+        int direction = get_direction_for_step(sd->skill_animation.step);
+        if (direction != -1) {
+            clif_send_animation_dir(bl, skill_env->target_id, direction);
+        }
+
+        sd->skill_animation.step++;
+
+        // Set the next timer
+        sd->skill_animation.tid = add_timer(tick + animation.start + animation.interval, skill_play_animation, bl->id, (intptr_t)skill_env);
+    } else {
+        // Clear the animation after completing all steps
+        skill_clear_animation(bl);
+    }
+
+    return 0;
+}
+
+
+
+
+void skill_clear_animation(struct block_list* bl) {
+    if (bl == NULL || bl->type != BL_PC) {
+        return;
+    }
+
+    map_session_data* sd = BL_CAST(BL_PC, bl);
+
+    if (sd->skill_animation.tid != INVALID_TIMER) {
+        delete_timer(sd->skill_animation.tid, skill_play_animation);
+        sd->skill_animation.tid = INVALID_TIMER;
+        sd->skill_animation.step = 0;
+    }
+}
 /** Reads skill database files */
 static void skill_readdb(void) {
 	int i;
@@ -25304,6 +25437,7 @@ static void skill_readdb(void) {
 		sv_readdb(dbsubpath2, "produce_db.txt"        , ',',   5,  5+2*MAX_PRODUCE_RESOURCE, MAX_SKILL_PRODUCE_DB, skill_parse_row_producedb, i > 0);
 		sv_readdb(dbsubpath1, "skill_changematerial_db.txt" , ',',   5,  5+2*MAX_SKILL_CHANGEMATERIAL_SET, MAX_SKILL_CHANGEMATERIAL_DB, skill_parse_row_changematerialdb, i > 0);
 		sv_readdb(dbsubpath1, "skill_damage_db.txt"         , ',',   4,  3+SKILLDMG_MAX, -1, skill_parse_row_skilldamage, i > 0);
+		sv_readdb(dbsubpath1, "skill_animation.txt"         , ',',   6,  6, -1, skill_parse_skill_animation, i > 0);
 
 		aFree(dbsubpath1);
 		aFree(dbsubpath2);
@@ -25324,7 +25458,7 @@ void skill_reload (void) {
 	magic_mushroom_db.clear();
 	reading_spellbook_db.clear();
 	skill_arrow_db.clear();
-
+	animation_lists.clear();
 	skill_readdb();
 
 	/* lets update all players skill tree : so that if any skill modes were changed they're properly updated */
@@ -25368,7 +25502,7 @@ void do_final_skill(void)
 	magic_mushroom_db.clear();
 	reading_spellbook_db.clear();
 	skill_arrow_db.clear();
-
+	animation_lists.clear();
 	db_destroy(skillunit_db);
 	db_destroy(skillusave_db);
 	db_destroy(bowling_db);
diff --git a/src/map/skill.hpp b/src/map/skill.hpp
index 5956955..f2fc6f1 100644
--- a/src/map/skill.hpp
+++ b/src/map/skill.hpp
@@ -2813,4 +2813,28 @@ int skill_get_time3(struct map_data *mapdata, uint16 skill_id, uint16 skill_lv);
 #define SKILL_CHK_ABR(skill_id)   ( (skill_id) >= ABR_SKILLBASE && (skill_id) < ABR_SKILLBASE+MAX_ABRSKILL )
 #define SKILL_CHK_GUILD(skill_id) ( (skill_id) >= GD_SKILLBASE && (skill_id) < GD_SKILLBASE+MAX_GUILDSKILL )
 
+int skill_calc_dir_counter_clockwise(int dir);
+
+struct s_animation_data {
+	int skill_id;
+	int start;
+	int interval;
+	int motion_speed;
+	int motion_count;
+	bool spin;
+};
+
+struct s_environment_data {
+	int skill_id;
+	int target_id;
+	int8 dir;
+};
+
+extern std::vector<s_animation_data> animation_lists;
+
+struct s_animation_data skill_animation_info(int skill_id);
+TIMER_FUNC(skill_play_animation);
+void skill_clear_animation(struct block_list* bl);
+
+
 #endif /* SKILL_HPP */
