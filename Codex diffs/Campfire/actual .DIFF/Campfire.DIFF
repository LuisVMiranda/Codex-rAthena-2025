diff --git a/Codex diffs/Campfire/README.md b/Codex diffs/Campfire/README.md
index e69d695..81a18b9 100644
--- a/Codex diffs/Campfire/README.md	
+++ b/Codex diffs/Campfire/README.md	
@@ -7,7 +7,10 @@ Reusable diff package for an item-driven temporary campfire system.
 - Spawns a temporary **bonfire NPC sprite** (`class: 10252`) near the player.
 - Duration, pulse interval, regen rates, range, cooldown and icon are now configurable via `battle_config` entries (`feature.campfire_*`).
 - Disabled automatically on **GvG** and **Battleground** maps.
-- Every pulse, the campfire heals owner and party members in range and shows icon `992` (or configured icon id) while active, with visible recovery numbers.
+- Campfire logic updates every 1000ms for zone/visual sync, while healing cadence follows `feature.campfire_tick_interval`.
+- Every active heal pulse, campfire heals owner and party members in range with visible recovery numbers.
+- Status icon is applied when entering the zone and removed when leaving/expiring (no countdown timer behavior).
+- NPC-top progress bar is sent from source packet handling (`clif_progressbar_npc_area`) without locking player movement.
 - Campfire auto-removes when time expires.
 
 ## Files in this package
diff --git a/Codex diffs/Campfire/assets/IMPLEMENTATION_NOTES.md b/Codex diffs/Campfire/assets/IMPLEMENTATION_NOTES.md
index 349d1af..b3a443d 100644
--- a/Codex diffs/Campfire/assets/IMPLEMENTATION_NOTES.md	
+++ b/Codex diffs/Campfire/assets/IMPLEMENTATION_NOTES.md	
@@ -41,3 +41,15 @@
 ## UI and progress
 - Icon is shown to healed targets while pulse effect is active.
 - Campfire countdown (final 5 seconds) is shown through `showscript` from source timers to avoid movement lock from progressbar-style blocking.
+
+## Tick/Heal split model
+- Runtime tick loop is fixed at **1000ms** for smooth zone enter/leave checks, icon state, and countdown/effect updates.
+- Actual HP/SP healing cadence remains controlled by `feature.campfire_tick_interval`.
+
+## Progress bar behavior
+- Instead of script-sleep `progressbar_npc`, the system updates NPC progressbar packets directly each tick (`nd->progressbar.*` + `clif_progressbar_npc_area`).
+- This keeps players fully movable while still showing progress over the campfire NPC.
+
+## Ground effects
+- Every 1000ms tick, ground skill poseffects are emitted across a square footprint derived from `feature.campfire_range`.
+- Effects naturally stop when the campfire expires/unloads.
diff --git a/Codex diffs/Campfire/required files/conf/battle/feature.conf.snippet.txt b/Codex diffs/Campfire/required files/conf/battle/feature.conf.snippet.txt
index 241cc16..d30da47 100644
--- a/Codex diffs/Campfire/required files/conf/battle/feature.conf.snippet.txt	
+++ b/Codex diffs/Campfire/required files/conf/battle/feature.conf.snippet.txt	
@@ -7,3 +7,5 @@ feature.campfire_hp_percent: 3
 feature.campfire_sp_percent: 3
 feature.campfire_cooldown: 30
 feature.campfire_icon: 992
+feature.campfire_ground_skill: 27
+feature.campfire_ground_skill_lv: 1
diff --git a/conf/battle/feature.conf b/conf/battle/feature.conf
index 3bdc343..d22372a 100644
--- a/conf/battle/feature.conf
+++ b/conf/battle/feature.conf
@@ -224,3 +224,7 @@ feature.campfire_sp_percent: 3
 feature.campfire_cooldown: 30
 // Icon ID shown while campfire effect is active. 0 disables icon.
 feature.campfire_icon: 992
+
+// Ground pulse visual effect (skill id/level) used on campfire area every second.
+feature.campfire_ground_skill: 27
+feature.campfire_ground_skill_lv: 1
diff --git a/src/map/battle.cpp b/src/map/battle.cpp
index 19c4445..a46a437 100644
--- a/src/map/battle.cpp
+++ b/src/map/battle.cpp
@@ -10728,6 +10728,8 @@ static const struct _battle_data {
 	{ "feature.campfire_sp_percent",        &battle_config.feature_campfire_sp_percent,     3,      0,      100,            },
 	{ "feature.campfire_cooldown",          &battle_config.feature_campfire_cooldown,       30,     0,      INT_MAX,        },
 	{ "feature.campfire_icon",              &battle_config.feature_campfire_icon,           992,    0,      INT_MAX,        },
+	{ "feature.campfire_ground_skill",      &battle_config.feature_campfire_ground_skill,   AL_WARP, 0,      MAX_SKILL,      },
+	{ "feature.campfire_ground_skill_lv",   &battle_config.feature_campfire_ground_skill_lv,1,      1,      MAX_SKILL_LEVEL, },
 
 	{ "mob_respawn_time",                   &battle_config.mob_respawn_time,                1000,   1000,   INT_MAX,        },
 	{ "mob_unlock_time",                    &battle_config.mob_unlock_time,                 2000,   0,      INT_MAX,        },
diff --git a/src/map/battle.hpp b/src/map/battle.hpp
index 5bc3170..650e9e7 100644
--- a/src/map/battle.hpp
+++ b/src/map/battle.hpp
@@ -805,6 +805,8 @@ struct Battle_Config
 	int32 feature_campfire_sp_percent;
 	int32 feature_campfire_cooldown;
 	int32 feature_campfire_icon;
+	int32 feature_campfire_ground_skill;
+	int32 feature_campfire_ground_skill_lv;
 
 	int32 mob_respawn_time;
 	int32 mob_unlock_time;
diff --git a/src/map/npc.cpp b/src/map/npc.cpp
index a1822b7..7b4c7a7 100644
--- a/src/map/npc.cpp
+++ b/src/map/npc.cpp
@@ -130,6 +130,7 @@ struct s_campfire_runtime {
 	t_tick end_tick = 0;
 	int32 tick_tid = INVALID_TIMER;
 	int32 expire_tid = INVALID_TIMER;
+	t_tick next_heal_tick = 0;
 	std::map<int32, bool> zone_state_by_char;
 };
 
@@ -139,6 +140,7 @@ static std::map<int32, t_tick> campfire_cooldown_by_owner;
 
 static void npc_campfire_cleanup( int32 npc_id, bool unload_npc );
 static int32 npc_campfire_regen_sub( block_list* bl, va_list ap );
+static void npc_campfire_emit_ground_effect( npc_data* nd );
 
 // Static functions
 static npc_data* npc_create_npc( int16 m, int16 x, int16 y );
@@ -6027,18 +6029,23 @@ bool npc_campfire_use_item( map_session_data& sd ){
 	const t_tick now = gettick();
 	const int32 duration_sec = pc_isvip( &sd ) ? battle_config.feature_campfire_vip_duration : battle_config.feature_campfire_nonvip_duration;
 	const int32 duration_ms = duration_sec * 1000;
-	const int32 tick_interval_ms = battle_config.feature_campfire_tick_interval * 1000;
+	const int32 tick_interval_ms = 1000;
 
 	s_campfire_runtime runtime = {};
 	runtime.owner_char_id = sd.status.char_id;
 	runtime.party_id = sd.status.party_id;
 	runtime.end_tick = now + duration_ms;
+	runtime.next_heal_tick = now;
 	runtime.tick_tid = add_timer( now + tick_interval_ms, npc_campfire_tick_timer, campfire_nd->id, 0 );
 	runtime.expire_tid = add_timer( runtime.end_tick, npc_campfire_expire_timer, campfire_nd->id, 0 );
 
 	campfire_runtime_by_npc[campfire_nd->id] = runtime;
 	campfire_npc_by_owner[sd.status.char_id] = campfire_nd->id;
 
+	campfire_nd->progressbar.color = 0x00FF00;
+	campfire_nd->progressbar.timeout = runtime.end_tick;
+	clif_progressbar_npc_area( campfire_nd );
+
 	campfire_cooldown_by_owner[sd.status.char_id] = now + battle_config.feature_campfire_cooldown * 1000;
 
 
@@ -6053,6 +6060,7 @@ static int32 npc_campfire_regen_sub( block_list* bl, va_list ap ){
 
 	int32 campfire_npc_id = va_arg( ap, int32 );
 	std::set<int32>* in_range_chars = va_arg( ap, std::set<int32>* );
+	bool do_heal = va_arg( ap, int32 ) != 0;
 	auto it = campfire_runtime_by_npc.find( campfire_npc_id );
 	if( it == campfire_runtime_by_npc.end() )
 		return 0;
@@ -6064,13 +6072,15 @@ static int32 npc_campfire_regen_sub( block_list* bl, va_list ap ){
 	if( !it->second.zone_state_by_char[tsd->status.char_id] ){
 		it->second.zone_state_by_char[tsd->status.char_id] = true;
 		clif_displaymessage( tsd->fd, "You entered the Campfire regeneration zone." );
+		if( battle_config.feature_campfire_icon > 0 )
+			clif_status_change( tsd, battle_config.feature_campfire_icon, 1, INFINITE_TICK, 0, 0, 0 );
 	}
 
-	const int32 hp_gain = std::max<int32>( 1, status_get_max_hp( tsd ) * battle_config.feature_campfire_hp_percent / 100 );
-	const int32 sp_gain = std::max<int32>( 1, status_get_max_sp( tsd ) * battle_config.feature_campfire_sp_percent / 100 );
-	status_heal( tsd, hp_gain, sp_gain, 3 );
-	if( battle_config.feature_campfire_icon > 0 )
-		clif_status_change( tsd, battle_config.feature_campfire_icon, 1, battle_config.feature_campfire_tick_interval * 1000 + 1000, 0, 0, 0 );
+	if( do_heal ){
+		const int32 hp_gain = std::max<int32>( 1, status_get_max_hp( tsd ) * battle_config.feature_campfire_hp_percent / 100 );
+		const int32 sp_gain = std::max<int32>( 1, status_get_max_sp( tsd ) * battle_config.feature_campfire_sp_percent / 100 );
+		status_heal( tsd, hp_gain, sp_gain, 3 );
+	}
 
 	return 0;
 }
@@ -6085,13 +6095,26 @@ static void npc_campfire_cleanup( int32 npc_id, bool unload_npc ){
 	if( it->second.expire_tid != INVALID_TIMER )
 		delete_timer( it->second.expire_tid, npc_campfire_expire_timer );
 
+	if( battle_config.feature_campfire_icon > 0 ){
+		for( const auto &pair : it->second.zone_state_by_char ){
+			if( pair.second ){
+				map_session_data* tsd = map_charid2sd( pair.first );
+				if( tsd != nullptr )
+					clif_status_change( tsd, battle_config.feature_campfire_icon, 0, 0, 0, 0, 0 );
+			}
+		}
+	}
+
 	campfire_npc_by_owner.erase( it->second.owner_char_id );
 	campfire_runtime_by_npc.erase( it );
 
 	if( unload_npc ){
 		npc_data* nd = map_id2nd( npc_id );
-		if( nd != nullptr )
+		if( nd != nullptr ){
+			nd->progressbar.timeout = 0;
+			clif_progressbar_npc_area( nd );
 			npc_unload( nd, true );
+		}
 	}
 }
 
@@ -6108,20 +6131,31 @@ TIMER_FUNC(npc_campfire_tick_timer){
 		return 0;
 	}
 
+	const t_tick now = gettick();
+	const int32 heal_interval_ms = battle_config.feature_campfire_tick_interval * 1000;
+	const bool do_heal = DIFF_TICK( now, it->second.next_heal_tick ) >= 0;
+	if( do_heal )
+		it->second.next_heal_tick = now + heal_interval_ms;
+
 	std::set<int32> in_range_chars;
-	map_foreachinallrange( npc_campfire_regen_sub, nd, battle_config.feature_campfire_range, BL_PC, id, &in_range_chars );
+	map_foreachinallrange( npc_campfire_regen_sub, nd, battle_config.feature_campfire_range, BL_PC, id, &in_range_chars, do_heal ? 1 : 0 );
 
 	for( auto &pair : it->second.zone_state_by_char ){
 		if( pair.second && in_range_chars.find( pair.first ) == in_range_chars.end() ){
 			pair.second = false;
 			map_session_data* tsd = map_charid2sd( pair.first );
-			if( tsd != nullptr )
+			if( tsd != nullptr ){
 				clif_displaymessage( tsd->fd, "You left the Campfire regeneration zone." );
+				if( battle_config.feature_campfire_icon > 0 )
+					clif_status_change( tsd, battle_config.feature_campfire_icon, 0, 0, 0, 0, 0 );
+			}
 		}
 	}
 
-	const t_tick now = gettick();
-	const int32 tick_interval_ms = battle_config.feature_campfire_tick_interval * 1000;
+	nd->progressbar.timeout = it->second.end_tick;
+	clif_progressbar_npc_area( nd );
+	npc_campfire_emit_ground_effect( nd );
+
 	const t_tick remain = DIFF_TICK( it->second.end_tick, now );
 	if( remain <= 5000 && remain > 0 ){
 		char countdown[32] = {};
@@ -6129,13 +6163,34 @@ TIMER_FUNC(npc_campfire_tick_timer){
 		clif_showscript( nd, countdown, AREA );
 	}
 
-	const int32 next_delay = (remain <= 5000) ? 1000 : tick_interval_ms;
-	if( remain > next_delay )
-		it->second.tick_tid = add_timer( now + next_delay, npc_campfire_tick_timer, id, 0 );
+	if( remain > 1000 )
+		it->second.tick_tid = add_timer( now + 1000, npc_campfire_tick_timer, id, 0 );
 
 	return 0;
 }
 
+static void npc_campfire_emit_ground_effect( npc_data* nd ){
+	if( nd == nullptr || battle_config.feature_campfire_ground_skill <= 0 )
+		return;
+
+	map_data* mapdata = map_getmapdata( nd->m );
+	if( mapdata == nullptr )
+		return;
+
+	const int32 size = std::max<int32>( 1, battle_config.feature_campfire_range );
+	const int32 radius = (size - 1) / 2;
+
+	for( int32 y = nd->y - radius; y <= nd->y + radius; ++y ){
+		if( y < 0 || y >= mapdata->ys )
+			continue;
+		for( int32 x = nd->x - radius; x <= nd->x + radius; ++x ){
+			if( x < 0 || x >= mapdata->xs )
+				continue;
+			clif_skill_poseffect( *nd, battle_config.feature_campfire_ground_skill, battle_config.feature_campfire_ground_skill_lv, x, y, gettick() );
+		}
+	}
+}
+
 TIMER_FUNC(npc_campfire_expire_timer){
 	auto it = campfire_runtime_by_npc.find( id );
 	if( it == campfire_runtime_by_npc.end() )
