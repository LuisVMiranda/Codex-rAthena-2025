 conf/battle_athena.conf        |   7 +
 conf/msg_conf/map_msg.conf     |   4 +
 conf/msg_conf/map_msg_por.conf |   4 +
 db/item_db.yml                 |   1 +
 src/map/achievement.cpp        |   4 +
 src/map/atcommand.cpp          |  43 +++-
 src/map/battle.cpp             |  17 ++
 src/map/battle.hpp             |  18 ++
 src/map/buyingstore.cpp        |   5 +-
 src/map/buyingstore.hpp        |   7 +
 src/map/chrif.cpp              |  24 ++-
 src/map/clif.cpp               |  78 ++++++-
 src/map/clif.hpp               |   4 +
 src/map/guild.cpp              |   5 +
 src/map/itemdb.cpp             |  46 ++++
 src/map/itemdb.hpp             |  19 ++
 src/map/mail.cpp               |  16 +-
 src/map/map.cpp                |  39 +++-
 src/map/map.hpp                |   3 +
 src/map/pc.cpp                 |  20 ++
 src/map/pc.hpp                 |  12 ++
 src/map/skill.cpp              |  71 +++++++
 src/map/skill.hpp              |   3 +
 src/map/status.cpp             |   4 +
 src/map/vending.cpp            | 471 ++++++++++++++++++++++++++++++++++++++---
 src/map/vending.hpp            |   5 +
 26 files changed, 893 insertions(+), 37 deletions(-)

diff --git a/conf/battle_athena.conf b/conf/battle_athena.conf
index fe03deb7e..3123e9a3e 100644
--- a/conf/battle_athena.conf
+++ b/conf/battle_athena.conf
@@ -59,3 +59,10 @@ import: conf/battle/misc.conf
 
 //Your custom config goes here.
 import: conf/import/battle_conf.txt
+
+// [RomuloSM]: Battle Import
+// Item/card-specific and crafting related options.
+import: conf/rsm-mod/battle/items.conf
+
+// Vending System
+import: conf/rsm-mod/battle/vendsystem/vending.conf
\ No newline at end of file
diff --git a/conf/msg_conf/map_msg.conf b/conf/msg_conf/map_msg.conf
index 49e09c276..69108b737 100644
--- a/conf/msg_conf/map_msg.conf
+++ b/conf/msg_conf/map_msg.conf
@@ -1817,3 +1817,7 @@
 
 //Custom translations
 import: conf/msg_conf/import/map_msg_eng_conf.txt
+
+// [RomuloSM]: Messages
+// Vending System
+import: conf/rsm-mod/msg_conf/vendsystem/map_msg_por.txt
\ No newline at end of file
diff --git a/conf/msg_conf/map_msg_por.conf b/conf/msg_conf/map_msg_por.conf
index 79d997e54..4748748e6 100644
--- a/conf/msg_conf/map_msg_por.conf
+++ b/conf/msg_conf/map_msg_por.conf
@@ -1698,3 +1698,7 @@
 
 //Custom translations
 import: conf/msg_conf/import/map_msg_por_conf.txt
+
+// [RomuloSM]: Mensagens
+// Vending System
+import: conf/rsm-mod/msg_conf/vendsystem/map_msg_por.txt
diff --git a/db/item_db.yml b/db/item_db.yml
index 4b326a4a7..e1e7566b8 100644
--- a/db/item_db.yml
+++ b/db/item_db.yml
@@ -95,3 +95,4 @@ Footer:
   - Path: db/re/item_db.yml
     Mode: Renewal
   - Path: db/import/item_db.yml
+  - Path: db/rsm-mod/item_db_vendsystem.yml
diff --git a/src/map/achievement.cpp b/src/map/achievement.cpp
index 7412e9412..2f7920d52 100644
--- a/src/map/achievement.cpp
+++ b/src/map/achievement.cpp
@@ -1096,6 +1096,10 @@ void achievement_update_objective(map_session_data *sd, enum e_achievement_group
 		va_list ap;
 		std::array<int, MAX_ACHIEVEMENT_OBJECTIVES> count = {};
 
+		// [RomuloSM]: Autovend Prevent Achievement
+		if( sd->autovend.active )
+			return;
+
 		va_start(ap, arg_count);
 		for (int i = 0; i < arg_count; i++){
 			std::string name = "ARG" + std::to_string(i);
diff --git a/src/map/atcommand.cpp b/src/map/atcommand.cpp
index ff5f07be7..aef0faa93 100644
--- a/src/map/atcommand.cpp
+++ b/src/map/atcommand.cpp
@@ -800,11 +800,13 @@ ACMD_FUNC(who) {
 				}
 				case 3: {
 					if (pc_has_permission(sd, PC_PERM_WHO_DISPLAY_AID))
-						StringBuf_Printf(&buf, msg_txt(sd,912), pl_sd->status.char_id, pl_sd->status.account_id);	// "(CID:%d/AID:%d) "
+						StringBuf_Printf(&buf, msg_txt(sd,912), pl_sd->status.char_id, pl_sd->autovend.account_id ? pl_sd->autovend.account_id : pl_sd->status.account_id);	// "(CID:%d/AID:%d) "
 					StringBuf_Printf(&buf, msg_txt(sd,343), pl_sd->status.name); // "Name: %s "
 					if (pc_get_group_id(pl_sd) > 0) // Player title, if exists
 						StringBuf_Printf(&buf, msg_txt(sd,344), pl_sd->group->name.c_str()); // "(%s) "
 					StringBuf_Printf(&buf, msg_txt(sd,348), mapindex_id2name(pl_sd->mapindex), pl_sd->bl.x, pl_sd->bl.y); // "| Location: %s %d %d"
+					if( pl_sd->autovend.account_id ) // [RomuloSM]: Auto Vending
+						StringBuf_Printf(&buf, msg_txt(sd,1762)); // "| Autovend
 					break;
 				}
 				default: {
@@ -6446,6 +6448,12 @@ ACMD_FUNC(autotrade) {
 		return -1;
 	}
 
+	// [RomuloSM]: Autovend
+	if( vending_autovend_check(sd->status.account_id) == true ) {
+		clif_displaymessage(fd, msg_txt(sd,1766));
+		return -1;
+	}
+
 	sd->state.autotrade = 1;
 	if (battle_config.autotrade_monsterignore)
 		sd->state.block_action |= PCBLOCK_IMMUNE;
@@ -10903,6 +10911,35 @@ ACMD_FUNC(setcard)
 
 #include <custom/atcommand.inc>
 
+// [RomuloSM]: Auto Vending
+ACMD_FUNC(autovend)
+{
+	nullpo_retr(-1, sd);
+
+	if( !battle_config.autovend_enable ) {
+		clif_displaymessage(fd, msg_txt(sd,1750)); // Autovend is not activated.
+		return -1;
+	}
+
+	if( map_getmapflag(sd->bl.m, MF_AUTOTRADE) != battle_config.autotrade_mapflag ) {
+		clif_displaymessage(fd, msg_txt(sd,1751)); // Autovend is not allowed on this map.
+		return -1;
+	}
+
+	if( pc_isdead(sd) ) {
+		clif_displaymessage(fd, msg_txt(sd,1752)); // You cannot autovend when dead.
+		return -1;
+	}
+
+	if( !sd->state.vending ) { //check if player is vending
+		clif_displaymessage(fd, msg_txt(sd,1753)); // "You should have a shop open to use @autovend."
+		return -1;
+	}
+
+	vending_create_autovend(sd);
+	return 0;
+}
+
 /**
  * Fills the reference of available commands in atcommand DBMap
  **/
@@ -11228,6 +11265,10 @@ void atcommand_basecommands(void) {
 		ACMD_DEFR(enchantgradeui, ATCMD_NOCONSOLE|ATCMD_NOAUTOTRADE),
 		ACMD_DEFR(roulette, ATCMD_NOCONSOLE|ATCMD_NOAUTOTRADE),
 		ACMD_DEF(setcard),
+
+		// [RomuloSM]: Autovend
+		ACMD_DEF(autovend),
+		ACMD_DEF2("av", autovend),
 	};
 	AtCommandInfo* atcommand;
 	int i;
diff --git a/src/map/battle.cpp b/src/map/battle.cpp
index 4e40a2cc8..447e572d5 100644
--- a/src/map/battle.cpp
+++ b/src/map/battle.cpp
@@ -10606,6 +10606,23 @@ static const struct _battle_data {
 	{ "feature.instance_allow_reconnect",   &battle_config.instance_allow_reconnect,        0,      0,      1,              },
 #endif
 
+	// [RomuloSM]: Global Coins
+	{ "item_zeny",							&battle_config.item_zeny,				41005,		0,   INT32_MAX, },
+	{ "item_cash",							&battle_config.item_cash,				41006,		0,	 INT32_MAX, },
+
+	// [RomuloSM]: Extended Vending
+	{ "extended_vending_enable",			&battle_config.extended_vending_enable,		1,		0,		     1, },
+	{ "extended_vending_report",			&battle_config.extended_vending_report,		1,		0,		     1, },
+	{ "extended_vending_broadcast",			&battle_config.extended_vending_broadcast,	1,		0,		     1, },
+	{ "extended_vending_showboard",			&battle_config.extended_vending_showboard,	1,		0,		     1, },
+
+	// [RomuloSM]: Auto Vending
+	{ "autovend_enable",                   &battle_config.autovend_enable,              1,      0,		     1, },
+	{ "autovend_same_account",		       &battle_config.autovend_same_account,		1,      0,		     1, },
+	{ "autovend_all_vending",			   &battle_config.autovend_all_vending,			1,      0,		     1, },
+	{ "autovend_save_onlycart",			   &battle_config.autovend_save_onlycart,		1,      0,		     1, },
+	{ "autovend_show_effect",			   &battle_config.autovend_show_effect,			1,      0,		     1, },
+
 #include <custom/battle_config_init.inc>
 };
 
diff --git a/src/map/battle.hpp b/src/map/battle.hpp
index 600e62775..c211b7f40 100644
--- a/src/map/battle.hpp
+++ b/src/map/battle.hpp
@@ -732,6 +732,24 @@ struct Battle_Config
 	int feature_banking_state_enforce;
 	int instance_allow_reconnect;
 
+	// [RomuloSM]: Global Coins
+	int item_zeny;
+	int item_cash;
+
+	// [RomuloSM]: Extended Vending
+	int extended_vending_enable;
+	int extended_vending_report;
+	int extended_vending_broadcast;
+	int extended_vending_showboard;
+
+	// [RomuloSM]: Auto Vending
+	int autovend_enable;
+	int avtovend_same_account;
+	int autovend_all_vending;
+	int autovend_same_account;
+	int autovend_save_onlycart;
+	int autovend_show_effect;
+
 #include <custom/battle_config_struct.inc>
 };
 
diff --git a/src/map/buyingstore.cpp b/src/map/buyingstore.cpp
index a0a6c9e1f..a7708a169 100644
--- a/src/map/buyingstore.cpp
+++ b/src/map/buyingstore.cpp
@@ -661,9 +661,9 @@ void buyingstore_reopen( map_session_data* sd ){
 void do_init_buyingstore_autotrade( void ) {
 	if(battle_config.feature_autotrade) {
 		if (Sql_Query(mmysql_handle,
-			"SELECT `id`, `account_id`, `char_id`, `sex`, `title`, `limit`, `body_direction`, `head_direction`, `sit` "
+			"SELECT `id`, `account_id`, `char_id`, `sex`, `title`, `limit`, `body_direction`, `head_direction`, `sit`, `autotrade` "
 			"FROM `%s` "
-			"WHERE `autotrade` = 1 AND `limit` > 0 AND (SELECT COUNT(`buyingstore_id`) FROM `%s` WHERE `buyingstore_id` = `id`) > 0 "
+			"WHERE (`autotrade` = 1 OR `autotrade` = 2) AND `limit` > 0 AND (SELECT COUNT(`buyingstore_id`) FROM `%s` WHERE `buyingstore_id` = `id`) > 0 "
 			"ORDER BY `id`;",
 			buyingstores_table, buyingstore_items_table ) != SQL_SUCCESS )
 		{
@@ -692,6 +692,7 @@ void do_init_buyingstore_autotrade( void ) {
 				Sql_GetData(mmysql_handle, 6, &data, NULL); at->dir = atoi(data);
 				Sql_GetData(mmysql_handle, 7, &data, NULL); at->head_dir = atoi(data);
 				Sql_GetData(mmysql_handle, 8, &data, NULL); at->sit = atoi(data);
+				Sql_GetData(mmysql_handle, 9, &data, NULL); at->autotrade = atoi(data);
 				at->count = 0;
 
 				if (battle_config.feature_autotrade_direction >= 0)
diff --git a/src/map/buyingstore.hpp b/src/map/buyingstore.hpp
index 12ba2a7b8..8ff72dc02 100644
--- a/src/map/buyingstore.hpp
+++ b/src/map/buyingstore.hpp
@@ -53,6 +53,13 @@ struct s_autotrader {
 	uint16 count; ///< Number of item in store
 	struct s_autotrade_entry **entries; ///< Store details
 	map_session_data *sd;
+
+	// [RomuloSM]: Extended Vending
+	t_itemid extvending_nameid;
+
+	// [RomuloSM]: Auto Vending
+	struct s_autotrader *next_autovend_at = NULL;
+	int autotrade; /// Autotrade type
 };
 
 int8 buyingstore_setup(map_session_data* sd, unsigned char slots);
diff --git a/src/map/chrif.cpp b/src/map/chrif.cpp
index 0e447afec..1a891234a 100644
--- a/src/map/chrif.cpp
+++ b/src/map/chrif.cpp
@@ -279,6 +279,12 @@ int chrif_save(map_session_data *sd, int flag) {
 
 	nullpo_retr(-1, sd);
 
+	if( sd->autovend.active && battle_config.autovend_save_onlycart ) {
+		status_change_clear(&sd->bl, 1);
+		intif_storage_save(sd,&sd->cart);
+		return 0;
+	}
+
 	pc_makesavestatus(sd);
 
 	if ( (flag&CSAVE_QUITTING) && sd->state.active) { //Store player data which is quitting
@@ -303,7 +309,7 @@ int chrif_save(map_session_data *sd, int flag) {
 
 	//For data sync
 	if (sd->state.storage_flag == 2)
-		storage_guild_storagesave(sd->status.account_id, sd->status.guild_id, flag);
+		storage_guild_storagesave(sd->autovend.account_id ? sd->autovend.account_id : sd->status.account_id, sd->status.guild_id, flag);
 	if (sd->premiumStorage.dirty)
 		storage_premiumStorage_save(sd);
 
@@ -318,7 +324,7 @@ int chrif_save(map_session_data *sd, int flag) {
 	WFIFOHEAD(char_fd, mmo_charstatus_len);
 	WFIFOW(char_fd,0) = 0x2b01;
 	WFIFOW(char_fd,2) = mmo_charstatus_len;
-	WFIFOL(char_fd,4) = sd->status.account_id;
+	WFIFOL(char_fd,4) = sd->autovend.account_id ? sd->autovend.account_id : sd->status.account_id;
 	WFIFOL(char_fd,8) = sd->status.char_id;
 	WFIFOB(char_fd,12) = (flag&CSAVE_QUIT) ? 1 : 0; //Flag to tell char-server this character is quitting.
 
@@ -417,6 +423,8 @@ int chrif_removemap(int fd) {
 // received after a character has been "final saved" on the char-server
 static void chrif_save_ack(int fd) {
 	chrif_auth_delete(RFIFOL(fd,2), RFIFOL(fd,6), ST_LOGOUT);
+	//chrif_check_shutdown();
+	vending_autovend(RFIFOL(fd, 2), RFIFOL(fd, 6));
 }
 
 // request to move a character between mapservers
@@ -1277,12 +1285,16 @@ int chrif_save_scdata(map_session_data *sd) { //parses the sc_data of the player
 	status_change *sc = &sd->sc;
 	const struct TimerData *timer;
 
+	// [RomuloSM]: Auto Vending
+	if( sd->autovend.active && battle_config.autovend_save_onlycart )
+		return 0;
+
 	chrif_check(-1);
 	tick = gettick();
 
 	WFIFOHEAD(char_fd, 14 + SC_MAX*sizeof(struct status_change_data));
 	WFIFOW(char_fd,0) = 0x2b1c;
-	WFIFOL(char_fd,4) = sd->status.account_id;
+	WFIFOL(char_fd,4) = sd->autovend.account_id ? sd->autovend.account_id : sd->status.account_id;
 	WFIFOL(char_fd,8) = sd->status.char_id;
 
 	for (i = 0; i < SC_MAX; i++) {
@@ -1322,12 +1334,16 @@ int chrif_skillcooldown_save(map_session_data *sd) {
 	t_tick tick;
 	const struct TimerData *timer;
 
+	// [RomuloSM]: Auto Vending
+	if( sd->autovend.active && battle_config.autovend_save_onlycart )
+		return 0;
+
 	chrif_check(-1);
 	tick = gettick();
 
 	WFIFOHEAD(char_fd, 14 + MAX_SKILLCOOLDOWN * sizeof (struct skill_cooldown_data));
 	WFIFOW(char_fd, 0) = 0x2b15;
-	WFIFOL(char_fd, 4) = sd->status.account_id;
+	WFIFOL(char_fd, 4) = sd->autovend.account_id ? sd->autovend.account_id : sd->status.account_id;
 	WFIFOL(char_fd, 8) = sd->status.char_id;
 	for (i = 0; i < MAX_SKILLCOOLDOWN; i++) {
 		if (!sd->scd[i])
diff --git a/src/map/clif.cpp b/src/map/clif.cpp
index 991b5b1b8..5ee7e89ea 100644
--- a/src/map/clif.cpp
+++ b/src/map/clif.cpp
@@ -1085,7 +1085,7 @@ static int clif_setlevel(struct block_list* bl) {
 /*==========================================
  * Prepares 'unit standing/spawning' packet
  *------------------------------------------*/
-static void clif_set_unit_idle( struct block_list* bl, bool walking, send_target target, struct block_list* tbl ){
+void clif_set_unit_idle( struct block_list* bl, bool walking, send_target target, struct block_list* tbl ){
 	nullpo_retv( bl );
 
 	map_session_data* sd = BL_CAST( BL_PC, bl );
@@ -1734,6 +1734,10 @@ int clif_spawn( struct block_list *bl, bool walking ){
 				clif_refreshlook(bl,bl->id,LOOK_ROBE,sd->status.robe,AREA);
 			clif_efst_status_change_sub(bl, bl, AREA);
 			clif_hat_effects(sd,bl,AREA);
+
+			// [RomuloSM]: Auto Vending
+			if( battle_config.autovend_enable && battle_config.autovend_show_effect && sd->autovend.active )
+				clif_specialeffect(bl, EF_BLUELIGHTBODY, AREA);
 		}
 		break;
 	case BL_MOB:
@@ -5105,6 +5109,10 @@ void clif_getareachar_unit( map_session_data* sd,struct block_list *bl ){
 				clif_refreshlook(&sd->bl,bl->id,LOOK_ROBE,tsd->status.robe,SELF);
 			clif_efst_status_change_sub(&sd->bl, bl, SELF);
 			clif_hat_effects(sd,bl,SELF);
+
+			// [RomuloSM]: Auto Vending
+			if( battle_config.autovend_enable && battle_config.autovend_show_effect && tsd->autovend.active )
+				clif_specialeffect_single(&tsd->bl, EF_BLUELIGHTBODY, sd->fd);
 		}
 		break;
 	case BL_MER: // Devotion Effects
@@ -7686,6 +7694,12 @@ void clif_openvendingreq(map_session_data* sd, int num)
 
 	nullpo_retv(sd);
 
+	// [RomuloSM] Vending shouldn't open if nameid is 0 and extended vending is enabled
+	if ((battle_config.extended_vending_enable&1) && sd->extended_vend.nameid == 0) {
+		sd->state.prevend = 0;
+		return;
+	}
+
 	fd = sd->fd;
 	WFIFOHEAD(fd,packet_len(0x12d));
 	WFIFOW(fd,0) = 0x12d;
@@ -11067,6 +11081,9 @@ void clif_parse_LoadEndAck(int fd,map_session_data *sd)
 		// Set facing direction before check below to update client
 		if (battle_config.spawn_direction)
 			unit_setdir(&sd->bl, sd->status.body_direction, false);
+
+		// [RomuloSM]: Auto Vending
+		sd->autovend.active = false;
 	} else {
 		//For some reason the client "loses" these on warp/map-change.
 		clif_updatestatus(sd,SP_STR);
@@ -13463,6 +13480,10 @@ void clif_parse_SelectArrow(int fd,map_session_data *sd) {
 		case NC_MAGICDECOY:
 			skill_magicdecoy(sd,p->itemId);
 			break;
+		// [RomuloSM]: Extended Vending
+		case MC_VENDING:
+			skill_vending(sd,p->itemId);
+			break;
 	}
 
 	clif_menuskill_clear(sd);
@@ -14171,6 +14192,16 @@ void clif_parse_OpenVending(int fd, map_session_data* sd){
 	if( message[0] == '\0' ) // invalid input
 		return;
 
+	// [RomuloSM]: Extended Vending
+	if( battle_config.extended_vending_enable && battle_config.extended_vending_showboard && sd->extended_vend.nameid ) {
+		char out_msg[1024];
+		std::shared_ptr<item_data> item = item_db.find(sd->extended_vend.nameid);
+		memset(out_msg, '\0', sizeof(out_msg));
+		strcat(strcat(strcat(strcat(out_msg, "["), item->ename.c_str()), "] "), message);
+		vending_openvending(sd, out_msg, data, len/8, NULL);
+		return;
+	}
+
 	vending_openvending(sd, message, data, len/8, NULL);
 }
 
@@ -25157,6 +25188,51 @@ void clif_parse_partybooking_reply( int fd, map_session_data* sd ){
 #endif
 }
 
+/**
+ * [RomuloSM] Extended Vending
+ **/
+int clif_vend(map_session_data *sd, int skill_lv) {
+
+	nullpo_ret( sd );
+
+	struct PACKET_ZC_MAKINGARROW_LIST *p = (struct PACKET_ZC_MAKINGARROW_LIST *)packet_buffer;
+	p->packetType = HEADER_ZC_MAKINGARROW_LIST;
+
+	int count = 0;
+	if( battle_config.item_zeny && item_db.find(battle_config.item_zeny) != nullptr ) {
+		p->items[count].itemId = client_nameid(battle_config.item_zeny);
+		count++;
+	}
+
+	if( battle_config.item_cash && item_db.find(battle_config.item_cash) != nullptr ) {
+		p->items[count].itemId = client_nameid(battle_config.item_cash);
+		count++;
+	}
+
+	for (const auto &entry : item_vend_db) {
+		auto item = entry.second;
+		std::shared_ptr<item_data> it;
+
+		if( item->nameid != battle_config.item_zeny && item->nameid != battle_config.item_cash && (it = item_db.find(item->nameid)) != nullptr ) {
+			p->items[count].itemId = client_nameid(item->nameid);
+			count++;
+		}
+	}
+
+	p->packetLength = sizeof( struct PACKET_ZC_MAKINGARROW_LIST ) + count * sizeof( struct PACKET_ZC_MAKINGARROW_LIST_sub );
+	clif_send( p, p->packetLength, &sd->bl, SELF );
+
+	if( count > 0 ){
+		sd->menuskill_id = MC_VENDING;
+		sd->menuskill_val = count;
+	}
+	else {
+		clif_skill_fail(sd, MC_VENDING, USESKILL_FAIL_LEVEL, 0);
+		return 0;
+	}
+	return 1;
+}
+
 /*==========================================
  * Main client packet processing function
  *------------------------------------------*/
diff --git a/src/map/clif.hpp b/src/map/clif.hpp
index 1bf10b262..677089c4f 100644
--- a/src/map/clif.hpp
+++ b/src/map/clif.hpp
@@ -632,6 +632,7 @@ void clif_charselectok(int id, uint8 ok);
 void clif_dropflooritem(struct flooritem_data* fitem, bool canShowEffect);
 void clif_clearflooritem(struct flooritem_data *fitem, int fd);
 
+void clif_set_unit_idle( struct block_list* bl, bool walking, send_target target, struct block_list* tbl );
 void clif_clearunit_single(int id, clr_type type, int fd);
 void clif_clearunit_area(struct block_list* bl, clr_type type);
 void clif_clearunit_delayed(struct block_list* bl, clr_type type, t_tick tick);
@@ -1253,4 +1254,7 @@ void clif_macro_reporter_status(map_session_data &sd, e_macro_report_status styp
 
 void clif_dynamicnpc_result( map_session_data& sd, e_dynamicnpc_result result );
 
+/// [RomuloSM] Extended Vending
+int clif_vend(map_session_data *sd, int skill_lv);
+
 #endif /* CLIF_HPP */
diff --git a/src/map/guild.cpp b/src/map/guild.cpp
index 373e5c03d..366bfdbc5 100644
--- a/src/map/guild.cpp
+++ b/src/map/guild.cpp
@@ -1291,6 +1291,11 @@ int guild_send_memberinfoshort(map_session_data *sd,int online) { // cleaned up
 
 	if(!online){
 		int i=guild_getindex(g->guild, sd->status.account_id,sd->status.char_id);
+
+		// [RomuloSM]: Auto Vending
+		if( sd->autovend.active )
+			return 0;
+
 		if(i>=0)
 			g->guild.member[i].sd=NULL;
 		else
diff --git a/src/map/itemdb.cpp b/src/map/itemdb.cpp
index c9cc886b8..4a4f430ec 100644
--- a/src/map/itemdb.cpp
+++ b/src/map/itemdb.cpp
@@ -35,6 +35,9 @@ ItemGroupDatabase itemdb_group;
 
 struct s_roulette_db rd;
 
+/// [RomuloSM]: Extended Vending
+ItemExtendedVendDatabase item_vend_db;
+
 static void itemdb_jobid2mapid(uint64 bclass[3], e_mapid jobmask, bool active);
 
 const std::string ItemDatabase::getDefaultLocation() {
@@ -4647,6 +4650,43 @@ bool RandomOptionGroupDatabase::option_get_id(std::string name, uint16 &id) {
 	return false;
 }
 
+/**
+ * [RomuloSM]: Extended Vending
+ **/
+const std::string ItemExtendedVendDatabase::getDefaultLocation() {
+	return std::string(db_path) + "/rsm-mod/item_vending_db.yml";
+}
+
+/**
+ * Reads and parses an entry from the item_vend_db.
+ * @param node: YAML node containing the entry.
+ * @return count of successfully parsed rows
+ */
+uint64 ItemExtendedVendDatabase::parseBodyNode( const ryml::NodeRef& node ) {
+	std::string name;
+
+	if (!this->asString(node, "Item", name))
+		return 0;
+
+	std::shared_ptr<item_data> id = item_db.search_aegisname( name.c_str() );
+
+	if (id == nullptr) {
+		this->invalidWarning(node["Item"], "Non-existant item '%s', skipping.\n", name.c_str());
+		return 0;
+	}
+
+	std::shared_ptr<s_item_vend_db> item = this->find(id->nameid);
+	bool exists = item != nullptr;
+	if ( !exists ) {
+		item = std::make_shared<s_item_vend_db>();
+		item->nameid = id->nameid;
+
+		this->put(id->nameid, item);
+	}
+
+	return 1;
+}
+
 /**
 * Read all item-related databases
 */
@@ -4695,6 +4735,9 @@ static void itemdb_read(void) {
 
 	if (battle_config.feature_roulette)
 		itemdb_parse_roulette_db();
+
+	// [RomuloSM] Extended Vending
+	item_vend_db.load();
 }
 
 /*==========================================
@@ -4760,6 +4803,9 @@ void itemdb_reload(void) {
 
 	mob_reload_itemmob_data();
 
+	// [RomuloSM]: Extended Vending
+	item_vend_db.reload();
+
 	// readjust itemdb pointer cache for each player
 	iter = mapit_geteachpc();
 	for( sd = (map_session_data*)mapit_first(iter); mapit_exists(iter); sd = (map_session_data*)mapit_next(iter) ) {
diff --git a/src/map/itemdb.hpp b/src/map/itemdb.hpp
index a48823fba..8587eedd7 100644
--- a/src/map/itemdb.hpp
+++ b/src/map/itemdb.hpp
@@ -2370,6 +2370,25 @@ public:
 
 extern ItemPackageDatabase item_package_db;
 
+/**
+ * [RomuloSM] Extended Vending
+ **/
+struct s_item_vend_db {
+	t_itemid nameid;
+};
+
+class ItemExtendedVendDatabase : public TypesafeYamlDatabase<t_itemid, s_item_vend_db> {
+public:
+	ItemExtendedVendDatabase() : TypesafeYamlDatabase("ITEM_VENDING_DB", 1) {
+
+	}
+
+	const std::string getDefaultLocation();
+	uint64 parseBodyNode( const ryml::NodeRef& node );
+};
+
+extern ItemExtendedVendDatabase item_vend_db;
+
 uint16 itemdb_searchname_array(std::map<t_itemid, std::shared_ptr<item_data>> &data, uint16 size, const char *str);
 struct item_data* itemdb_search(t_itemid nameid);
 
diff --git a/src/map/mail.cpp b/src/map/mail.cpp
index 12e9a5bb1..6e6a259b0 100644
--- a/src/map/mail.cpp
+++ b/src/map/mail.cpp
@@ -332,8 +332,13 @@ void mail_getattachment(map_session_data* sd, struct mail_message* msg, int zeny
 			}else{
 				char check = pc_checkadditem( sd, item[i].nameid, item[i].amount );
 
+				// [RomuloSM]: Global Coin
+				if( item[i].nameid == battle_config.item_cash ) {
+					pc_getcash(sd, (int)item[i].amount, 0, LOG_TYPE_MAIL);
+					item_received = true;
+				}
 				// Add the item normally
-				if( check != CHKADDITEM_OVERAMOUNT && pc_additem( sd, &item[i], item[i].amount, LOG_TYPE_MAIL ) == ADDITEM_SUCCESS ){
+				else if( check != CHKADDITEM_OVERAMOUNT && pc_additem( sd, &item[i], item[i].amount, LOG_TYPE_MAIL ) == ADDITEM_SUCCESS ){
 					item_received = true;
 
 					// Only reduce slots if it really required a new slot
@@ -388,8 +393,13 @@ void mail_deliveryfail(map_session_data *sd, struct mail_message *msg){
 
 	for( i = 0; i < MAIL_MAX_ITEM; i++ ){
 		if( msg->item[i].amount > 0 ){
-			// Item receive (due to failure)
-			pc_additem(sd, &msg->item[i], msg->item[i].amount, LOG_TYPE_MAIL);
+			// [RomuloSM]: Global Coin
+			if( msg->item[i].nameid == battle_config.item_cash )
+				pc_getcash(sd, (int)msg->item[i].amount, 0, LOG_TYPE_MAIL);
+			else {
+				// Item receive (due to failure)
+				pc_additem(sd, &msg->item[i], msg->item[i].amount, LOG_TYPE_MAIL);
+			}
 			zeny += battle_config.mail_attachment_price;
 		}
 	}
diff --git a/src/map/map.cpp b/src/map/map.cpp
index ececaf9fd..c88df6428 100644
--- a/src/map/map.cpp
+++ b/src/map/map.cpp
@@ -127,7 +127,7 @@ static struct block_list *bl_list[BL_LIST_MAX];
 static int bl_list_count = 0;
 
 #ifndef MAP_MAX_MSG
-	#define MAP_MAX_MSG 1550
+	#define MAP_MAX_MSG 1767
 #endif
 
 struct map_data map[MAX_MAP_PER_SERVER];
@@ -2093,7 +2093,8 @@ int map_quit(map_session_data *sd) {
 
 	pc_itemcd_do(sd,false);
 
-	npc_script_event(sd, NPCE_LOGOUT);
+	if( !sd->autovend.active ) // [RomuloSM]: Prevent Autovend
+		npc_script_event(sd, NPCE_LOGOUT);
 
 	//Unit_free handles clearing the player related data,
 	//map_quit handles extra specific data which is related to quitting normally
@@ -2158,6 +2159,11 @@ int map_quit(map_session_data *sd) {
 	pc_macro_detector_disconnect(*sd);
 	chrif_save(sd, CSAVE_QUIT|CSAVE_INVENTORY|CSAVE_CART);
 	unit_free_pc(sd);
+
+	// [RomuloSM]: Autovend Clear
+	if( sd->autovend.active ) {
+		aFree(sd);
+	}
 	return 0;
 }
 
@@ -4815,6 +4821,35 @@ bool map_setmapflag_sub(int16 m, enum e_mapflag mapflag, bool status, union u_ma
 	return true;
 }
 
+// [RomuloSM]: Get new blocklist ID.
+int map_get_new_bl_id(void)
+{
+	static int last_object_id = END_ACCOUNT_NUM - 1;
+	int i;
+
+	// find a free id
+	i = last_object_id + 1;
+	while (i != last_object_id) {
+		if (i == END_ACCOUNT_NUM + END_ACCOUNT_NUM)
+			i = END_ACCOUNT_NUM;
+
+		if (!idb_exists(id_db, i))
+			break;
+
+		++i;
+	}
+
+	if (i == last_object_id) {
+		ShowError("map_addobject: no free object id!\n");
+		return 0;
+	}
+
+	// update cursor
+	last_object_id = i;
+
+	return i;
+}
+
 /**
  * @see DBApply
  */
diff --git a/src/map/map.hpp b/src/map/map.hpp
index fcd64ea75..e9ca37f41 100644
--- a/src/map/map.hpp
+++ b/src/map/map.hpp
@@ -1221,6 +1221,9 @@ bool map_setmapflag_sub(int16 m, enum e_mapflag mapflag, bool status, union u_ma
 #define map_getmapflag(m, mapflag) map_getmapflag_sub(m, mapflag, NULL)
 #define map_setmapflag(m, mapflag, status) map_setmapflag_sub(m, mapflag, status, NULL)
 
+// [RomuloSM]: Get new blocklist ID.
+int map_get_new_bl_id(void);
+
 #define CHK_ELEMENT(ele) ((ele) > ELE_NONE && (ele) < ELE_MAX) /// Check valid Element
 #define CHK_ELEMENT_LEVEL(lv) ((lv) >= 1 && (lv) <= MAX_ELE_LEVEL) /// Check valid element level
 #define CHK_RACE(race) ((race) > RC_NONE_ && (race) < RC_MAX) /// Check valid Race
diff --git a/src/map/pc.cpp b/src/map/pc.cpp
index 1cb25fad6..0072d7dbc 100755
--- a/src/map/pc.cpp
+++ b/src/map/pc.cpp
@@ -2026,6 +2026,22 @@ bool pc_authok(map_session_data *sd, uint32 login_id2, time_t expiration_time, i
 		return false;
 	}
 
+	// [RomuloSM]: Find Auto Vending
+	map_session_data* pl_sd;
+	struct s_mapiterator* iter = mapit_getallusers();
+	for (pl_sd = (TBL_PC*)mapit_first(iter); mapit_exists(iter); pl_sd = (TBL_PC*)mapit_next(iter))
+	{
+		if (sd->status.account_id == pl_sd->autovend.account_id && sd->status.char_id == pl_sd->status.char_id)
+		{
+			vending_closevending(pl_sd);
+			unit_remove_map_pc(pl_sd, CLR_OUTSIGHT);
+			unit_free_pc(pl_sd);
+			aFree(pl_sd);
+			ShowInfo("Autovend: '" CL_WHITE "%d" CL_RESET "' kicked.\n", sd->status.char_id);
+		}
+	}
+	mapit_free(iter);
+
 	//Set the map-server used job id. [Skotlex]
 	uint64 class_ = pc_jobid2mapid(sd->status.class_);
 	if (class_ == -1 || !job_db.exists(sd->status.class_)) { //Invalid class?
@@ -2080,6 +2096,10 @@ bool pc_authok(map_session_data *sd, uint32 login_id2, time_t expiration_time, i
 	sd->regen.tick.hp = tick;
 	sd->regen.tick.sp = tick;
 
+	// [RomuloSM]: Autovend
+	sd->autovend.active = 0;
+	sd->autovend.account_id = 0;
+
 	for(int i = 0; i < MAX_SPIRITBALL; i++)
 		sd->spirit_timer[i] = INVALID_TIMER;
 
diff --git a/src/map/pc.hpp b/src/map/pc.hpp
index c37cd4fb5..2b3557b57 100644
--- a/src/map/pc.hpp
+++ b/src/map/pc.hpp
@@ -941,6 +941,18 @@ public:
 	s_macro_detect macro_detect;
 
 	std::vector<uint32> party_booking_requests;
+
+	// [RomuloSM]: Extended Vending System
+	struct {
+		t_itemid nameid;
+		int level;
+	} extended_vend;
+
+	// [RomuloSM]: Auto Vending
+	struct {
+		uint32 account_id;
+		bool active;
+	} autovend;
 };
 
 extern struct eri *pc_sc_display_ers; /// Player's SC display table
diff --git a/src/map/skill.cpp b/src/map/skill.cpp
index fe764c201..ad233facb 100755
--- a/src/map/skill.cpp
+++ b/src/map/skill.cpp
@@ -9166,7 +9166,54 @@ int skill_castend_nodamage_id (struct block_list *src, struct block_list *bl, ui
 					sd->state.pending_vending_ui = true;
 					intif_storage_save(sd, &sd->cart);
 				}
+				// [RomuloSM]: Extended Vending
+				else if( battle_config.extended_vending_enable ) {
+					std::shared_ptr<item_data> item;
+					t_itemid defItem = 0;
+					char output[1024];
+					int c = 0, d = 0;
+					sd->extended_vend.level = skill_lv;
+					if (battle_config.item_zeny)
+						d++;
+					if (battle_config.item_cash)
+						d++;
+
+					c = d;
+					for (const auto &entry : item_vend_db) {
+						auto iv = entry.second;
+
+						if( (item = item_db.find(iv->nameid)) != nullptr && item->nameid != battle_config.item_zeny && item->nameid != battle_config.item_cash ) {
+							if( !defItem )
+								defItem = iv->nameid;
+							c++;
+						}
+					}
+
+					if (c > 1)
+						clif_vend(sd, sd->extended_vend.level);
+					else {
+						sd->state.prevend = 1;
+						if (c) {
+							item = item_db.find(battle_config.item_zeny);
+							if( item == nullptr )
+								item = item_db.find(battle_config.item_cash);
+							if( item == nullptr )
+								item = item_db.find(defItem);
+							sd->extended_vend.nameid = item != nullptr ? item->nameid : 0;
+							sprintf(output, msg_txt(sd,1755), itemdb_ename(sd->extended_vend.nameid));
+							clif_messagecolor(&sd->bl, color_table[COLOR_CYAN], output, false, SELF);
+							clif_openvendingreq(sd, 2 + sd->extended_vend.level);
+						}
+						else {
+							sd->extended_vend.nameid = 0;
+							// Instantly open the vending UI
+							sd->state.pending_vending_ui = false;
+							clif_openvendingreq(sd, 2 + sd->extended_vend.level);
+						}
+					}
+				}
 				else{
+					sd->extended_vend.nameid = 0;
 					// Instantly open the vending UI
 					sd->state.pending_vending_ui = false;
 					clif_openvendingreq(sd,2+skill_lv);
@@ -23385,6 +23432,30 @@ int skill_get_time3(struct map_data *mapdata, uint16 skill_id, uint16 skill_lv)
 	return time;
 }
 
+/**
+ * [RomuloSM]: Extended Vending
+ **/
+int skill_vending(map_session_data *sd, t_itemid nameid) {
+	std::shared_ptr<item_data> item;
+	char output[1024];
+	nullpo_ret(sd);
+
+	if (!pc_can_give_items(sd) || (nameid <= 0 || nameid >= (INT32_MAX)) || (item = item_db.find(nameid)) == NULL) {
+		sd->state.prevend = 0;
+		sd->extended_vend.nameid = 0;
+		sd->state.workinprogress = WIP_DISABLE_NONE;
+		clif_skill_fail(sd, MC_VENDING, USESKILL_FAIL_LEVEL, 0);
+	}
+	else {
+		sd->extended_vend.nameid = nameid;
+		sd->state.prevend = 1;
+		clif_openvendingreq(sd, 2 + sd->extended_vend.level);
+		sprintf(output, msg_txt(sd,1756), item->ename.c_str());
+		clif_messagecolor(&sd->bl, color_table[COLOR_CYAN], output, false, SELF);
+	}
+	return 0;
+}
+
 const std::string SkillDatabase::getDefaultLocation() {
 	return std::string(db_path) + "/skill_db.yml";
 }
diff --git a/src/map/skill.hpp b/src/map/skill.hpp
index c22e0ad70..80486ebd0 100644
--- a/src/map/skill.hpp
+++ b/src/map/skill.hpp
@@ -2787,6 +2787,9 @@ enum sc_type skill_get_sc(int16 skill_id);
 void skill_reveal_trap_inarea(struct block_list *src, int range, int x, int y);
 int skill_get_time3(struct map_data *mapdata, uint16 skill_id, uint16 skill_lv);
 
+// [RomuloSM]: Extended Vending
+int skill_vending(map_session_data *sd, t_itemid nameid);
+
 /// Variable name of copied skill by Plagiarism
 #define SKILL_VAR_PLAGIARISM "CLONE_SKILL"
 /// Variable name of copied skill level by Plagiarism
diff --git a/src/map/status.cpp b/src/map/status.cpp
index 13aa873ec..f9aabfa9c 100644
--- a/src/map/status.cpp
+++ b/src/map/status.cpp
@@ -10010,6 +10010,10 @@ int status_change_start(struct block_list* src, struct block_list* bl,enum sc_ty
 	sd = BL_CAST(BL_PC, bl);
 	vd = status_get_viewdata(bl);
 
+	// [RomuloSM]: Autovend
+	if( sd && sd->autovend.active )
+		return 0;
+
 	undead_flag = battle_check_undead(status->race,status->def_ele);
 	// Check for immunities / sc fails
 	switch (type) {
diff --git a/src/map/vending.cpp b/src/map/vending.cpp
index 873d16717..8411a3268 100755
--- a/src/map/vending.cpp
+++ b/src/map/vending.cpp
@@ -16,20 +16,30 @@
 #include "battle.hpp"
 #include "buyingstore.hpp"
 #include "buyingstore.hpp" // struct s_autotrade_entry, struct s_autotrader
+#include "channel.hpp"
 #include "chrif.hpp"
+#include "clan.hpp"
 #include "clif.hpp"
+#include "intif.hpp" // intif_Mail_send
+#include "guild.hpp"
+#include "intif.hpp"
 #include "itemdb.hpp"
 #include "log.hpp"
 #include "npc.hpp"
 #include "path.hpp"
+#include "party.hpp"
 #include "pc.hpp"
 #include "pc_groups.hpp"
+#ifdef RANKED_SYSTEM
+#include "ranked.hpp"
+#endif
 
 static uint32 vending_nextid = 0; ///Vending_id counter
 static DBMap *vending_db; ///DB holder the vender : charid -> map_session_data
 
 //Autotrader
 static DBMap *vending_autotrader_db; /// Holds autotrader info: char_id -> struct s_autotrader
+std::map<uint32, std::vector<uint32>> vending_acc_to_chardb;  /// Holds autotrader info: account_id -> [ char_id... ] [RomuloSM]: Autovend
 static void vending_autotrader_remove(struct s_autotrader *at, bool remove);
 static int vending_autotrader_free(DBKey key, DBData *data, va_list ap);
 
@@ -67,6 +77,9 @@ void vending_closevending(map_session_data* sd)
 
 		sd->state.vending = false;
 		sd->vender_id = 0;
+		// [RomuloSM]: Auto Vending
+		//if( sd->autovend.account_id )
+		//	sd->autovend.account_id = 0;
 		clif_closevendingboard(&sd->bl, 0);
 		idb_remove(vending_db, sd->status.char_id);
 	}
@@ -92,6 +105,21 @@ void vending_vendinglistreq(map_session_data* sd, int id)
 		return;
 	}
 
+	// [RomuloSM]: Auto Vending
+	if ( battle_config.autovend_enable && vsd->autovend.account_id == sd->status.account_id && !battle_config.autovend_same_account ) {
+		clif_displaymessage(sd->fd, msg_txt(sd,1749)); // you're not allowed to see your own shops
+		return;
+	}
+
+	// [RomuloSM] Extended Vending
+	if( battle_config.extended_vending_enable && vsd->extended_vend.nameid ) {
+		char output[1024];
+		sprintf(output, msg_txt(sd,1757), vsd->status.name, itemdb_ename(vsd->extended_vend.nameid));
+		if( battle_config.extended_vending_broadcast )
+			clif_broadcast(&sd->bl, output, (int)strlen(output) + 1, 0x10, SELF);
+		else
+			clif_messagecolor(&sd->bl, color_table[COLOR_CYAN], output, false, SELF);
+	}
 	sd->vended_id = vsd->vender_id;  // register vending uid
 
 	clif_vendinglist( sd, vsd );
@@ -122,11 +150,16 @@ static double vending_calc_tax(map_session_data *sd, double zeny)
  */
 void vending_purchasereq(map_session_data* sd, int aid, int uid, const uint8* data, int count)
 {
-	int i, j, cursor, w, new_ = 0, blank, vend_list[MAX_VENDING];
+	int i, j, cursor, w, new_ = 0, blank,  mailprofit = 0, vend_list[MAX_VENDING];
 	double z;
 	struct s_vending vending[MAX_VENDING]; // against duplicate packets
 	map_session_data* vsd = map_id2sd(aid);
 
+	// [RomuloSM]: Extended & Auto Vending
+	struct mail_message msg;
+	char mailBody[1000];
+	double total = 0;
+	
 	nullpo_retv(sd);
 	if( vsd == NULL || !vsd->state.vending || vsd->bl.id == sd->bl.id )
 		return; // invalid shop
@@ -171,14 +204,70 @@ void vending_purchasereq(map_session_data* sd, int aid, int uid, const uint8* da
 			vend_list[i] = j;
 
 		z += ((double)vsd->vending[j].value * (double)amount);
-		if( z > (double)sd->status.zeny || z < 0. || z > (double)MAX_ZENY ) {
-			clif_buyvending(sd, idx, amount, 1); // you don't have enough zeny
-			return;
-		}
-		if( z + (double)vsd->status.zeny > (double)MAX_ZENY && !battle_config.vending_over_max ) {
-			clif_buyvending(sd, idx, vsd->vending[j].amount, 4); // too much zeny = overflow
-			return;
+		// [RomuloSM]: Extended Vending
+		if( battle_config.extended_vending_enable && vsd->extended_vend.nameid ) {
+			if( vsd->extended_vend.nameid == battle_config.item_zeny ) {
+				if( (double)sd->status.zeny < z  || z < 0. || (double)MAX_ZENY < z ) {
+					char output[1024];
+					sprintf(output, msg_txt(sd,1758), itemdb_ename(vsd->extended_vend.nameid));
+					clif_messagecolor(&sd->bl, color_table[COLOR_CYAN], output, false, SELF);
+					//clif_buyvending(sd, idx, amount, 1); // you don't have enough zeny
+					return;
+				}
+				else if( (double)MAX_ZENY < (z + (double)vsd->status.zeny) && !battle_config.vending_over_max ) {
+					clif_buyvending(sd, idx, vsd->vending[j].amount, 4); // too much zeny = overflow
+					return;
+				}
+			}
+			else if( vsd->extended_vend.nameid == battle_config.item_cash ) {
+				if( z > sd->cashPoints || z < 0. || (double)MAX_ZENY < z ) {
+					char output[1024];
+					sprintf(output, msg_txt(sd,1758), itemdb_ename(vsd->extended_vend.nameid));
+					clif_messagecolor(&sd->bl, color_table[COLOR_CYAN], output, false, SELF);
+					return;
+				}
+			}
+			else {
+				int k, loot_count = 0, vsd_w = 0;
+				for( k = 0; k < MAX_INVENTORY; k++ ) {
+					if( sd->inventory.u.items_inventory[k].bound ) {
+						clif_displaymessage(sd->fd, msg_txt(sd,1759));
+						return;
+					}
+
+					if( sd->inventory.u.items_inventory[k].nameid == vsd->extended_vend.nameid )
+						loot_count += sd->inventory.u.items_inventory[k].amount;
+				}
+ 
+				if(z > loot_count || z < 0 ) {
+					char output[1024];
+					sprintf(output, msg_txt(sd,1758), itemdb_ename(vsd->extended_vend.nameid));
+					clif_messagecolor(&sd->bl, color_table[COLOR_CYAN], output, false, SELF);
+					return;
+				}
 
+				if( pc_inventoryblank(vsd) <= 0 ) {
+					clif_messagecolor(&sd->bl, color_table[COLOR_CYAN], msg_txt(sd,1760), false, SELF);
+					return;
+				}
+
+				vsd_w += itemdb_weight(vsd->extended_vend.nameid) * (int)z;
+				if( !vsd->autovend.active && (vsd_w + vsd->weight) > vsd->max_weight ) {
+					clif_messagecolor(&sd->bl, color_table[COLOR_CYAN], msg_txt(sd,1761), false, SELF);
+					return;
+				}
+			}
+ 		}
+		else {
+			if( z > (double)sd->status.zeny || z < 0. || z > (double)MAX_ZENY ) {
+				clif_buyvending(sd, idx, amount, 1); // you don't have enough zeny
+				return;
+			}
+			if( z + (double)vsd->status.zeny > (double)MAX_ZENY && !battle_config.vending_over_max ) {
+				clif_buyvending(sd, idx, vsd->vending[j].amount, 4); // too much zeny = overflow
+				return;
+
+			}
 		}
 		w += itemdb_weight(vsd->cart.u.items_cart[idx].nameid) * amount;
 		if( w + sd->weight > sd->max_weight ) {
@@ -213,10 +302,80 @@ void vending_purchasereq(map_session_data* sd, int aid, int uid, const uint8* da
 		}
 	}
 
-	pc_payzeny(sd, (int)z, LOG_TYPE_VENDING, vsd->status.char_id);
-	achievement_update_objective(sd, AG_SPEND_ZENY, 1, (int)z);
-	z = vending_calc_tax(sd, z);
-	pc_getzeny(vsd, (int)z, LOG_TYPE_VENDING, sd->status.char_id);
+	// [RomuloSM]: Extended & Auto Vending Message
+	bool report_mail = (battle_config.autovend_enable && vsd->autovend.active) || (battle_config.extended_vending_enable && battle_config.extended_vending_report && vsd->extended_vend.nameid);
+	if( report_mail ) {
+		memset(&msg, 0, sizeof(struct mail_message));
+		msg.dest_id = vsd->status.char_id;
+		safestrncpy(msg.send_name, "Server", NAME_LENGTH);
+		safestrncpy(msg.title, msg_txt(vsd,1763), MAIL_TITLE_LENGTH);
+	}
+
+	// [RomuloSM]: Auto Vending
+	if( vsd->autovend.account_id ) {
+		if( battle_config.extended_vending_enable ) {
+			// Extended Vending Payment
+			if( vsd->extended_vend.nameid == battle_config.item_zeny || !vsd->extended_vend.nameid ) {
+				pc_payzeny(sd, (int)z, LOG_TYPE_VENDING, vsd->status.char_id);
+				achievement_update_objective(sd, AG_SPEND_ZENY, 1, (int)z);
+				total = z = vending_calc_tax(sd, z);
+				log_zeny(*vsd, LOG_TYPE_VENDING, sd->status.char_id, (int)z);
+				msg.zeny = (int)total;
+			}
+			else if( vsd->extended_vend.nameid == battle_config.item_cash ) {
+				total = z;
+				pc_paycash(sd, (int)z, 0, LOG_TYPE_VENDING);
+				msg.item[0].nameid = (t_itemid)battle_config.item_cash;
+				msg.item[0].amount = (int)z;
+				msg.item[0].identify = 1;
+				msg.item[0].attribute = 0;
+			}
+			else {
+				msg.item[0].nameid = (t_itemid)vsd->extended_vend.nameid;
+				msg.item[0].amount = (int)z;
+				msg.item[0].identify = 1;
+				msg.item[0].attribute = 0;
+
+				total = z;
+				pc_delitem(sd, pc_search_inventory(sd, vsd->extended_vend.nameid), (int)z, 0, 6, LOG_TYPE_VENDING);
+			}
+		}
+		else {
+			total = z = vending_calc_tax(sd, z);
+			msg.zeny = (int)total;
+		}
+	}
+	// [RomuloSM]: Extended Vending
+	else if( battle_config.extended_vending_enable && vsd->extended_vend.nameid ) {
+		if( vsd->extended_vend.nameid == battle_config.item_zeny || !vsd->extended_vend.nameid ) {
+			pc_payzeny(sd, (int)z, LOG_TYPE_VENDING, vsd->status.char_id);
+			achievement_update_objective(sd, AG_SPEND_ZENY, 1, (int)z);
+			total = z = vending_calc_tax(sd, z);
+			pc_getzeny(vsd, (int)z, LOG_TYPE_VENDING, sd->status.char_id);
+		}
+		else if( vsd->extended_vend.nameid == battle_config.item_cash ) {
+			total = z;
+			pc_paycash(sd, (int)z, 0, LOG_TYPE_VENDING);
+			pc_getcash(vsd, (int)z, 0, LOG_TYPE_VENDING);
+		}
+		else {
+			for( i = 0; i < MAX_INVENTORY; i++ ) {
+				if( sd->inventory.u.items_inventory[i].nameid == vsd->extended_vend.nameid ) {
+					struct item *item;
+					item = &sd->inventory.u.items_inventory[i];
+					pc_additem(vsd, item, (int)z, LOG_TYPE_VENDING);
+				}
+			}
+			total = z;
+			pc_delitem(sd, pc_search_inventory(sd, vsd->extended_vend.nameid), (int)z, 0, 6, LOG_TYPE_VENDING);
+		}
+	}
+	else {
+		pc_payzeny(sd, (int)z, LOG_TYPE_VENDING, vsd->status.char_id);
+		achievement_update_objective(sd, AG_SPEND_ZENY, 1, (int)z);
+		total = z = vending_calc_tax(sd, z);
+		pc_getzeny(vsd, (int)z, LOG_TYPE_VENDING, sd->status.char_id);
+	}
 
 	for( i = 0; i < count; i++ ) {
 		short amount = *(uint16*)(data + 4*i + 0);
@@ -224,6 +383,9 @@ void vending_purchasereq(map_session_data* sd, int aid, int uid, const uint8* da
 		idx -= 2;
 		z = 0.; // zeny counter
 
+		// Store Item Name [Easycore]
+		const char *item_name = itemdb_ename(vsd->cart.u.items_cart[idx].nameid);
+
 		// vending item
 		pc_additem(sd, &vsd->cart.u.items_cart[idx], amount, LOG_TYPE_VENDING);
 		vsd->vending[vend_list[i]].amount -= amount;
@@ -239,16 +401,54 @@ void vending_purchasereq(map_session_data* sd, int aid, int uid, const uint8* da
 			}
 		}
 
+		// [RomuloSM]: Extended & Auto Vending
+		t_itemid itemID = vsd->cart.u.items_cart[idx].nameid;
+
 		pc_cart_delitem(vsd, idx, amount, 0, LOG_TYPE_VENDING);
 		z = vending_calc_tax(sd, z);
 		clif_vendingreport(vsd, idx, amount, sd->status.char_id, (int)z);
 
-		//print buyer's name
-		if( battle_config.buyer_name ) {
-			char temp[256];
-			sprintf(temp, msg_txt(sd,265), sd->status.name);
-			clif_messagecolor(&vsd->bl, color_table[COLOR_LIGHT_GREEN], temp, false, SELF);
+		// [RomuloSM]: Extended & Auto Vending
+		if( report_mail ) {
+			if( i == 0 ) {
+				sprintf(mailBody, msg_txt(sd,1764), sd->status.name);
+				sprintf(mailBody, "%s\r\n\r\n", mailBody);
+			}
+#if PACKETVER >= 20150513 // Old mail box is too shorter
+			if( i >= 0 && strlen(mailBody) < 180 ) {
+				if( battle_config.extended_vending_enable ) {
+					sprintf(mailBody + strlen(mailBody), msg_txt(vsd,1765), amount, itemdb_ename(itemID), (int)z, vsd->extended_vend.nameid?itemdb_ename(vsd->extended_vend.nameid):"Zeny");
+				}
+				else {
+					sprintf(mailBody + strlen(mailBody), msg_txt(vsd,1765), amount, itemdb_ename(itemID), (int)z, "Zeny");
+				}
+				sprintf(mailBody, "%s\r\n", mailBody);
+			}
+			else if( strlen(mailBody) < 200 )
+				sprintf(mailBody + strlen(mailBody), "%s\r\n",msg_txt(vsd,1766));
+#endif
+			//print buyer's name
+			if( battle_config.buyer_name ) {
+				char temp[256];
+				sprintf(temp, msg_txt(sd,265), sd->status.name);
+				clif_messagecolor(&vsd->bl, color_table[COLOR_LIGHT_GREEN], temp, false, SELF);
+			}
 		}
+		//print buyer's name
+		else if( battle_config.buyer_name ) {
+ 			char temp[256];
+ 			sprintf(temp, msg_txt(sd,265), sd->status.name);
+ 			clif_messagecolor(&vsd->bl, color_table[COLOR_LIGHT_GREEN], temp, false, SELF);
+ 		}
+	}
+
+	// [RomuloSM]: Extended & Auto Vending Messages
+	if( report_mail ) {
+		safestrncpy(msg.body, mailBody, MAIL_BODY_LENGTH);
+		msg.status = MAIL_NEW;
+		msg.type = MAIL_INBOX_NORMAL;
+		msg.timestamp = time(NULL);
+		intif_Mail_send(0, &msg);
 	}
 
 	// compact the vending list
@@ -370,10 +570,10 @@ int8 vending_openvending(map_session_data* sd, const char* message, const uint8*
 	
 	Sql_EscapeString( mmysql_handle, message_sql, sd->message );
 
-	if( Sql_Query( mmysql_handle, "INSERT INTO `%s`(`id`, `account_id`, `char_id`, `sex`, `map`, `x`, `y`, `title`, `autotrade`, `body_direction`, `head_direction`, `sit`) "
-		"VALUES( %d, %d, %d, '%c', '%s', %d, %d, '%s', %d, '%d', '%d', '%d' );",
-		vendings_table, sd->vender_id, sd->status.account_id, sd->status.char_id, sd->status.sex == SEX_FEMALE ? 'F' : 'M', map_getmapdata(sd->bl.m)->name, sd->bl.x, sd->bl.y, message_sql, sd->state.autotrade, at ? at->dir : sd->ud.dir, at ? at->head_dir : sd->head_dir, at ? at->sit : pc_issit(sd) ) != SQL_SUCCESS ) {
-		Sql_ShowDebug(mmysql_handle);
+	if( Sql_Query( mmysql_handle, "INSERT INTO `%s`(`id`, `account_id`, `char_id`, `sex`, `map`, `x`, `y`, `title`, `autotrade`, `body_direction`, `head_direction`, `sit`, `extended_vending_item`) "
+		"VALUES( %d, %d, %d, '%c', '%s', %d, %d, '%s', %d, '%d', '%d', '%d', '%u' );",
+		vendings_table, sd->vender_id, sd->status.account_id, sd->status.char_id, sd->status.sex == SEX_FEMALE ? 'F' : 'M', map_getmapdata(sd->bl.m)->name, sd->bl.x, sd->bl.y, message_sql, sd->state.autotrade, at ? at->dir : sd->ud.dir, at ? at->head_dir : sd->head_dir, at ? at->sit : pc_issit(sd), sd->extended_vend.nameid ) != SQL_SUCCESS ) {
+ 		Sql_ShowDebug(mmysql_handle);
 	}
 
 	StringBuf_Init(&buf);
@@ -390,7 +590,11 @@ int8 vending_openvending(map_session_data* sd, const char* message, const uint8*
 	clif_openvending(sd,sd->bl.id,sd->vending);
 	clif_showvendingboard( *sd );
 
-	idb_put(vending_db, sd->status.char_id, sd);
+	// [RomuloSM]: Auto Vending
+	if( battle_config.autovend_all_vending|| (at && at->autotrade == 2 && battle_config.autovend_enable) )
+		vending_create_autovend(sd);
+	else
+		idb_put(vending_db, sd->status.char_id, sd);
 
 	return 0;
 }
@@ -417,6 +621,211 @@ bool vending_search(map_session_data* sd, t_itemid nameid)
 	return true;
 }
 
+/**
+ * [RomuloSM] Autovend DB
+ * @param account_id : player account_id
+ * @param char_id : player char_id
+ */
+void vending_autovend(uint32 account_id, uint32 char_id)
+{
+	std::map<uint32, std::vector<uint32>>::iterator vector_it = vending_acc_to_chardb.find(account_id);
+
+	if (vector_it != vending_acc_to_chardb.end()) {
+		if (!vending_acc_to_chardb[account_id].empty()) {
+
+			std::vector<uint32>::iterator vector_charit = std::find(vending_acc_to_chardb[account_id].begin(), vending_acc_to_chardb[account_id].end(), char_id);
+
+			vending_acc_to_chardb[account_id].erase(vector_charit);
+
+			if (!vending_acc_to_chardb[account_id].empty()) {
+				struct s_autotrader* at = (struct s_autotrader *)uidb_get(vending_autotrader_db, vending_acc_to_chardb[account_id][0]);
+				if (at)
+					chrif_authreq(at->sd, true);
+			} else {
+				vending_acc_to_chardb.erase(vector_it);
+			}
+		} else {
+			vending_acc_to_chardb.erase(vector_it);
+		}
+	}
+}
+
+/**
+ * [RomuloSM] Check Autovend exist
+ * @param account_id : player account_id
+ */
+bool vending_autovend_check(uint32 account_id, uint32 char_id)
+{
+	map_session_data* sd;
+	struct s_mapiterator* iter = mapit_getallusers();
+	bool exist = false;
+	for (sd = (TBL_PC*)mapit_first(iter); mapit_exists(iter); sd = (TBL_PC*)mapit_next(iter))
+	{
+		if( char_id && sd->status.char_id != char_id )
+			continue;
+
+		if( account_id == sd->autovend.account_id ) {
+			exist = true;
+			break;
+		}
+	}
+	mapit_free(iter);
+	return exist;
+}
+
+/**
+ * [RomuloSM]: Create autovend
+ * @param sd : vender session (player)
+ */
+bool vending_create_autovend(map_session_data* sd)
+{
+	// Clear Status
+	int val1 = sd->sc.getSCE(SC_PUSH_CART) ? sd->sc.getSCE(SC_PUSH_CART)->val1 : 0;
+	skill_clear_unitgroup(&sd->bl);
+	status_change_clear(&sd->bl,1);
+
+	map_session_data* sdd = NULL;
+
+	CREATE(sdd, TBL_PC, 1);
+	memcpy(&sdd->bl, &sd->bl, sizeof(struct block_list));
+	memcpy(&sdd->status, &sd->status, sizeof(struct mmo_charstatus));
+	memcpy(&sdd->status.skill, &sd->status.skill, sizeof(s_skill));
+	memcpy(&sdd->state, &sd->state, sizeof(map_session_data::s_state));
+	memcpy(&sdd->vd, &sd->vd, sizeof(struct view_data));
+	memcpy(&sdd->ud, &sd->ud, sizeof(struct unit_data));
+	memcpy(&sdd->sc, &sd->sc, sizeof(status_change));
+	memcpy(&sdd->cart, &sd->cart, sizeof(struct s_storage));
+	memcpy(&sdd->base_status, &sd->base_status, sizeof(struct status_data));
+	memcpy(&sdd->battle_status, &sd->battle_status, sizeof(struct status_data));
+	memcpy(&sdd->group, &sd->group, sizeof(struct s_player_group));
+
+	sdd->bl.id = map_get_new_bl_id();
+	sdd->bl.prev = NULL;
+	sdd->bl.next = NULL;
+	sdd->status.account_id = sdd->bl.id;
+	sdd->status.char_id = sd->status.char_id;
+
+	sdd->invincible_timer = INVALID_TIMER;
+	sdd->pvp_timer = INVALID_TIMER;
+	sdd->rental_timer = INVALID_TIMER;
+	sdd->followtimer = INVALID_TIMER;
+	sdd->expiration_tid = INVALID_TIMER;
+	sdd->npc_timer_id = INVALID_TIMER;
+	sdd->autotrade_tid = INVALID_TIMER;
+	sdd->autovend.active = true;
+
+	// Make sure abort all NPCs
+	npc_event_dequeue(sdd);
+	pc_cleareventtimer(sdd);
+
+	sdd->state.active = 0; //to be set to 1 after player is fully authed and loaded.
+	strcpy(sdd->status.name, sd->status.name);
+	sdd->permissions = sd->permissions;
+
+	sdd->mapindex = sd->mapindex;
+	sdd->bl.x = sd->bl.x;
+	sdd->bl.y = sd->bl.y;
+
+	// Party Join
+	sdd->status.party_id = sd->status.party_id;
+	if (sdd->status.party_id)
+		party_member_joined(sdd);
+
+	// Guild Join
+	sdd->status.guild_id = sd->status.guild_id;
+	if (sdd->status.guild_id)
+		guild_send_memberinfoshort(sdd, 1);
+
+	// Clan Join
+	sdd->status.clan_id = sd->status.clan_id;
+	if (sdd->status.clan_id)
+		clan_member_joined(sdd);
+
+#ifdef PRESENCE_SYSTEM
+	// [RomuloSM]: Clear Timer Events
+	sdd->presence.timer = INVALID_TIMER;
+	pc_presence_deltimer(sdd,battle_config.presence_reset_logout);
+#endif
+
+#ifdef RANKED_SYSTEM
+	// [RomuloSM]: Ranked System
+	sdd->ranked.display_timer = INVALID_TIMER;
+	ranked_destroy_timer(sdd);
+#endif
+
+	struct map_data *mapdata = map_getmapdata(sdd->bl.m);
+	mapdata->users++;
+	if (!pc_isinvisible(sdd)) { // increment the number of pvp players on the map
+		mapdata->users_pvp++;
+	}
+	sdd->state.debug_remove_map = 0;
+
+	if (map_addblock(&sdd->bl))
+		return 1;
+
+	map_addiddb(&sdd->bl);
+
+	clif_set_unit_idle(&sdd->bl, false, AREA, &sd->bl);
+	for (int i = 0; i < MAX_CART; i++) {
+		memcpy(&sdd->cart.u.items_cart[i], &sd->cart.u.items_cart[i], sizeof(struct item));
+	}
+
+	sc_start(&sd->bl, &sd->bl, SC_PUSH_CART, 100, val1, 0);
+	sc_start(&sdd->bl, &sdd->bl, SC_PUSH_CART, 100, val1, 0);
+
+	// Open shop
+	sdd->state.prevend = 0;
+	sdd->state.vending = true;
+	sdd->state.workinprogress = WIP_DISABLE_NONE;
+	sdd->vender_id = sd->vender_id;
+	sdd->vend_num = sd->vend_num;
+	sdd->extended_vend.level = sd->extended_vend.level;
+	sdd->extended_vend.nameid = sd->extended_vend.nameid;
+	sdd->autovend.account_id = sd->status.account_id;
+	safestrncpy(sdd->message, sd->message, MESSAGE_SIZE);
+	for (int i = 0; i < MAX_VENDING; i++) {
+		sdd->vending[i].index = sd->vending[i].index;
+		sdd->vending[i].amount = sd->vending[i].amount;
+		sdd->vending[i].value = sd->vending[i].value;
+	}
+	sd->vender_id = 0;
+	sd->state.keepshop = true;
+	sd->state.vending = false;
+	clif_showvendingboard( *sdd );
+
+	// effects
+	clif_specialeffect(&sdd->bl, EF_ROTATE_LINE_BLUE, AREA);
+	clif_specialeffect(&sdd->bl, EF_BLUELIGHTBODY, AREA);
+
+	// autotrade	
+	sdd->state.autotrade = 1;
+	if (battle_config.autotrade_monsterignore)
+		sdd->state.block_action |= PCBLOCK_IMMUNE;
+
+	if (sdd->state.vending) {
+		if (Sql_Query(mmysql_handle, "UPDATE `%s` SET `autotrade` = 2 WHERE `id` = %d;", vendings_table, sdd->vender_id) != SQL_SUCCESS) {
+			Sql_ShowDebug(mmysql_handle);
+		}
+	}
+	else if (sdd->state.buyingstore) {
+		if (Sql_Query(mmysql_handle, "UPDATE `%s` SET `autotrade` = 2 WHERE `id` = %d;", buyingstores_table, sdd->buyer_id) != SQL_SUCCESS) {
+			Sql_ShowDebug(mmysql_handle);
+		}
+	}
+
+	sdd->state.active = 1;
+
+	channel_pcquit(sd, 0xF); //leave all chan
+	clif_authfail_fd(sd->fd, 15);
+
+	chrif_save(sd, CSAVE_AUTOTRADE);
+
+	map_quit(sd);
+
+	idb_put(vending_db, sdd->status.char_id, sdd);
+	return 1;
+}
+
 /**
  * Searches for all items in a vending, that match given ids, price and possible cards.
  * @param sd : The vender session to search into
@@ -548,6 +957,9 @@ void vending_reopen( map_session_data* sd )
 				clif_sitting(&sd->bl);
 			}
 
+			// [RomuloSM]: Extended Vending
+			sd->extended_vend.nameid = at->extvending_nameid;
+
 			// Immediate save
 			chrif_save(sd, CSAVE_AUTOTRADE);
 
@@ -576,9 +988,9 @@ void do_init_vending_autotrade(void)
 {
 	if (battle_config.feature_autotrade) {
 		if (Sql_Query(mmysql_handle,
-			"SELECT `id`, `account_id`, `char_id`, `sex`, `title`, `body_direction`, `head_direction`, `sit` "
+			"SELECT `id`, `account_id`, `char_id`, `sex`, `title`, `body_direction`, `head_direction`, `sit`, `autotrade`, `extended_vending_item` "
 			"FROM `%s` "
-			"WHERE `autotrade` = 1 AND (SELECT COUNT(`vending_id`) FROM `%s` WHERE `vending_id` = `id`) > 0 "
+			"WHERE (`autotrade` = 1 OR `autotrade` = 2) AND (SELECT COUNT(`vending_id`) FROM `%s` WHERE `vending_id` = `id`) > 0 "
 			"ORDER BY `id`;",
 			vendings_table, vending_items_table ) != SQL_SUCCESS )
 		{
@@ -606,6 +1018,8 @@ void do_init_vending_autotrade(void)
 				Sql_GetData(mmysql_handle, 5, &data, NULL); at->dir = atoi(data);
 				Sql_GetData(mmysql_handle, 6, &data, NULL); at->head_dir = atoi(data);
 				Sql_GetData(mmysql_handle, 7, &data, NULL); at->sit = atoi(data);
+				Sql_GetData(mmysql_handle, 8, &data, NULL); at->autotrade = atoi(data);
+				Sql_GetData(mmysql_handle, 9, &data, NULL); at->extvending_nameid = atoi(data);		// [RomuloSM] Extended Vending
 				at->count = 0;
 
 				if (battle_config.feature_autotrade_direction >= 0)
@@ -615,6 +1029,10 @@ void do_init_vending_autotrade(void)
 				if (battle_config.feature_autotrade_sit >= 0)
 					at->sit = battle_config.feature_autotrade_sit;
 
+				// [RomuloSM] Extended Vending
+				if( !battle_config.extended_vending_enable )
+					at->extvending_nameid = 0;
+
 				// initialize player
 				CREATE(at->sd, map_session_data, 1); // TODO: Dont use Memory Manager allocation anymore and rely on the C++ container
 				pc_setnewpc(at->sd, at->account_id, at->char_id, 0, gettick(), at->sex, 0);
@@ -623,6 +1041,10 @@ void do_init_vending_autotrade(void)
 					at->sd->state.block_action |= PCBLOCK_IMMUNE;
 				else
 					at->sd->state.block_action &= ~PCBLOCK_IMMUNE;
+
+				// [RomuloSM]: Extended Vending
+				at->sd->extended_vend.nameid = at->extvending_nameid;
+
 				chrif_authreq(at->sd, true);
 				uidb_put(vending_autotrader_db, at->char_id, at);
 			}
@@ -732,6 +1154,7 @@ void do_final_vending(void)
 {
 	db_destroy(vending_db);
 	vending_autotrader_db->destroy(vending_autotrader_db, vending_autotrader_free);
+	vending_acc_to_chardb.clear();
 }
 
 /**
diff --git a/src/map/vending.hpp b/src/map/vending.hpp
index 8f886d9cc..21c96e097 100644
--- a/src/map/vending.hpp
+++ b/src/map/vending.hpp
@@ -32,4 +32,9 @@ bool vending_search(map_session_data* sd, t_itemid nameid);
 bool vending_searchall(map_session_data* sd, const struct s_search_store_search* s);
 void vending_update(map_session_data &sd);
 
+// [RomuloSM]: Auto Vending
+void vending_autovend(uint32 account_id, uint32 char_id);
+bool vending_autovend_check(uint32 account_id, uint32 char_id = 0);
+bool vending_create_autovend(map_session_data* sd);
+
 #endif /* _VENDING_HPP_ */
